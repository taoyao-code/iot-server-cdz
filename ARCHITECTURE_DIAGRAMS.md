# IoT 服务器 - 架构图

## 1. 系统组件层次结构

```
┌─────────────────────────────────────────────────────────────────┐
│                        IoT 服务器                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────────┐        ┌──────────────────────────┐  │
│  │   TCP 网关           │        │    HTTP 服务器           │  │
│  │ (端口 6000)          │        │ (端口 7055)              │  │
│  │                      │        │                          │  │
│  │ • 连接限制           │        │ • API 路由               │  │
│  │ • 速率限制           │        │ • 健康检查               │  │
│  │ • 熔断器             │        │ • 指标端点               │  │
│  └──────┬───────────────┘        └──────┬───────────────────┘  │
│         │                               │                      │
│         ├─► Mux (协议检测)              │                      │
│         │   • 嗅探魔术字节              │                      │
│         │   • 分发到适配器              │                      │
│         │                               │                      │
│         ├─► AP3000适配器 / BKV适配器   │                      │
│         │   • 流解码器                  │                      │
│         │   • 路由表                    │                      │
│         │   • 帧处理器                  │                      │
│         │                               │                      │
│         └─► 会话管理◄────────────────┘                      │
│             (Redis 支持)                                      │
│             • bind(phyID)                                     │
│             • GetConn()                                       │
│             • IsOnline()                                      │
│                                                               │
│  ┌────────────────────────────────────────────────────────┐  │
│  │          数据持久化层                                   │  │
│  ├────────────────────────────────────────────────────────┤  │
│  │                                                         │  │
│  │  PostgreSQL              Redis                         │  │
│  │  • devices               • session:device:{phyID}      │  │
│  │  • ports                 • outbound:queue              │  │
│  │  • orders                • outbound:processing:*       │  │
│  │  • cmd_log               • outbound:dead               │  │
│  │  • outbound_queue        • event queue                 │  │
│  │                                                         │  │
│  └────────────────────────────────────────────────────────┘  │
│                                                               │
│  ┌────────────────────────────────────────────────────────┐  │
│  │          后台工作线程 (Goroutines)                      │  │
│  ├────────────────────────────────────────────────────────┤  │
│  │ • RedisWorker (出站轮询)                                │  │
│  │ • EventQueueWorkers (webhook 推送)                     │  │
│  │ • OrderMonitor (过期订单检测)                           │  │
│  │ • PortStatusSyncer (状态监控)                          │  │
│  └────────────────────────────────────────────────────────┘  │
│                                                               │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 入站消息流 (设备 → 服务器)

```
                          设备
                            ↓
                    TCP/IP 网络
                            ↓
            ┌───────────────────────────────┐
            │     TCPServer.Accept()         │
            │   监听 :6000                   │
            └───────────┬───────────────────┘
                        ↓
            ┌───────────────────────────────┐
            │   创建 ConnContext            │
            │   + 读缓冲区                  │
            │   + 写队列                    │
            └───────────┬───────────────────┘
                        ↓
            ┌───────────────────────────────┐
            │   Mux.BindToConn()            │
            │   设置 OnRead 回调            │
            └───────────┬───────────────────┘
                        ↓
        ┌───────────────────────────────────┐
        │   OnRead 被调用 (首次)            │
        │   + 检查前 8 字节 (魔术字节)      │
        ├───────────────────────────────────┤
        │  匹配?                            │
        ├─────────────────────────────────┬─┤
        │                                 │  │
        V                                 V  V
   ┌─────────────────┐         ┌──────────────────┐
   │ AP3000适配器    │         │   BKV适配器      │
   │ 魔术字节: D"N   │         │ 魔术字节: FCFE/FCFF │
   │ (0x44,0x22,0x4E)│         │ (0xFC,0xFE/FF)   │
   └────────┬────────┘         └────────┬─────────┘
            │                           │
            V                           V
   ┌─────────────────────────────────────────────┐
   │       StreamDecoder.Feed(bytes)             │
   │   (处理分帧、半包等)                        │
   │       → [Frame1, Frame2, ...]               │
   └────────────┬────────────────────────────────┘
                ↓
   ┌─────────────────────────────────────────────┐
   │       RouterTable.Route(frame)              │
   │   查找: handlers[frame.Cmd]                 │
   └────────────┬────────────────────────────────┘
                ↓
   ┌─────────────────────────────────────────────┐
   │   处理器执行 (来自 conn_handler.go)         │
   │                                             │
   │   wrapBKVHandler() 或直接注册               │
   │   ├─ bindIfNeeded(phyID)                    │
   │   │  └─ sess.Bind(phyID, connContext)      │
   │   │     → Redis: session:device:{phyID}    │
   │   │                                         │
   │   ├─ sess.OnHeartbeat(phyID, now)          │
   │   │  └─ Redis: 更新 lastSeen               │
   │   │                                         │
   │   ├─ Metrics: 增加计数器                   │
   │   │                                         │
   │   └─ 协议特定处理器                         │
   │      • HandleRegister()                    │
   │      • HandleHeartbeat()                   │
   │      • HandleControl()                     │
   │      • HandleChargeEnd()                   │
   │      • HandleBalanceQuery()                │
   │      • 等等                                │
   └────────────┬────────────────────────────────┘
                ↓
   ┌─────────────────────────────────────────────┐
   │   数据库持久化层                            │
   │   (internal/storage/pg/repo.go)             │
   │                                             │
   │   ├─ EnsureDevice(phyID)                    │
   │   │  INSERT ... ON CONFLICT DO UPDATE       │
   │   │                                         │
   │   ├─ UpsertPortState(...)                   │
   │   │  INSERT ... ON CONFLICT DO UPDATE       │
   │   │                                         │
   │   ├─ UpsertOrderProgress(...)               │
   │   │  INSERT ... ON CONFLICT DO UPDATE       │
   │   │                                         │
   │   ├─ SettleOrder(...)                       │
   │   │  INSERT ... ON CONFLICT DO UPDATE       │
   │   │                                         │
   │   └─ InsertCmdLog(...)                      │
   │      INSERT (审计跟踪)                      │
   └─────────────────────────────────────────────┘
```

---

## 3. 出站消息流 (服务器 → 设备)

```
        HTTP 客户端 (第三方或内部)
                ↓
    POST /api/v1/third/devices/{device_id}/charge
                ↓
    ┌─────────────────────────────────────────┐
    │  ThirdPartyHandler.StartCharge()        │
    │                                         │
    │  1. 解析 JSON 请求体                    │
    │  2. 检查 sess.IsOnline(phyID)           │
    │  3. 在数据库中 CreateOrder()            │
    │  4. 构建协议命令                        │
    └──────────┬────────────────────────────────┘
               ↓
    ┌─────────────────────────────────────────┐
    │  outboundAdapter.SendDownlink()         │
    │                                         │
    │  1. 编码帧 (bkv.Build 等)               │
    │  2. 从命令类型获取优先级                │
    │  3. 创建 OutboundMessage                │
    └──────────┬────────────────────────────────┘
               ↓
    ┌──────────────────────────────────────────────┐
    │  queue.Enqueue(msg)                         │
    │  (internal/storage/redis/outbound_queue.go) │
    │                                              │
    │  1. 检查队列长度 (降级检查)                 │
    │     - len > 200: 拒绝优先级 > 5             │
    │     - len > 500: 拒绝优先级 > 2             │
    │     - len > 1000: 拒绝优先级 > 1            │
    │                                              │
    │  2. 计算分数:                               │
    │     score = priority * 1e12 + unixnano      │
    │                                              │
    │  3. Redis ZADD outbound:queue               │
    │     {score, "ID:JSON_DATA"}                 │
    │                                              │
    │  4. 返回 202 Accepted 给 HTTP 客户端        │
    └──────────┬────────────────────────────────────┘
               ↓
    ╔════════════════════════════════════════════════╗
    ║  RedisWorker (持续轮询)                       ║
    ║  在后台 goroutine 中运行                      ║
    ║  每 throttleMs 触发一次 (默认 100ms)          ║
    ╠════════════════════════════════════════════════╣
    ║                                                ║
    ║  1. queue.Dequeue()                           ║
    ║     → Redis ZPOPMIN (原子操作，最低分数)      ║
    ║     → 返回最高优先级消息                      ║
    ║                                                ║
    ║  2. queue.MarkProcessing(msg)                 ║
    ║     → Redis HSET outbound:processing:{phyID} ║
    ║     → 设置 TTL 为 2 倍消息超时时间            ║
    ║                                                ║
    ║  3. sess.GetConn(msg.PhyID)                   ║
    ║     → 检查 Redis 会话数据                     ║
    ║     → 验证 serverID 匹配                      ║
    ║     → 检查心跳超时                            ║
    ║     → 返回 ConnContext 或 nil                 ║
    ║                                                ║
    ║  4. 如果连接不可用:                           ║
    ║     → queue.MarkFailed(msg, reason)           ║
    ║     → Retry < MaxRetry: 重新入队              ║
    ║     → Retry >= MaxRetry: 移至死信队列         ║
    ║                                                ║
    ║  5. 如果连接可用:                             ║
    ║     → connContext.Write(frame)                ║
    ║     → (同步 socket 写入)                      ║
    ║                                                ║
    ║  6. 如果写入成功:                             ║
    ║     → queue.MarkSuccess(msg)                  ║
    ║     → 从 outbound:processing 删除             ║
    ║     → 增加发送计数器                          ║
    ║                                                ║
    ║  7. 如果写入失败:                             ║
    ║     → queue.MarkFailed(msg, error)            ║
    ║     → (重试逻辑，见上面 #4)                   ║
    ║                                                ║
    ╚════════════════════════════════════════════════╝
               ↓
            设备 (通过 TCP socket)
            接收帧
               ↓
            设备处理命令
            发送 ACK 帧 (0x0F 等)
               ↓
        ┌─────────────────────────────┐
        │  入站处理器处理              │
        │  ACK 帧                     │
        │                             │
        │  repo.AckOutboundByMsgID()  │
        │  → 更新 outbound_queue      │
        │     SET status=2 (成功)     │
        └─────────────────────────────┘
```

---

## 4. 会话生命周期

```
                设备连接到 TCP
                        ↓
        ┌───────────────────────────────────┐
        │   TCP 连接已接受                  │
        │   创建 ConnContext                │
        │   调用 Mux.BindToConn()           │
        └──────────┬────────────────────────┘
                   ↓
        ┌───────────────────────────────────┐
        │   接收到第一条消息                │
        │   (心跳或其他命令)                │
        └──────────┬────────────────────────┘
                   ↓
        ┌───────────────────────────────────┐
        │   bindIfNeeded(phyID)             │
        │   在处理器包装器中调用            │
        └──────────┬────────────────────────┘
                   ↓
        ┌───────────────────────────────────┐
        │   sess.Bind(phyID, connContext)   │
        ├───────────────────────────────────┤
        │   RedisManager.Bind():            │
        │                                   │
        │   1. 生成 connID (UUID)           │
        │                                   │
        │   2. 存储到 Redis:                │
        │      session:device:{phyID}       │
        │      → {                          │
        │          phyID,                   │
        │          connID,                  │
        │          serverID,                │
        │          lastSeen: now,           │
        │          lastTCPDown: null,       │
        │          lastAckTimeout: null     │
        │        }                          │
        │      TTL: 2x heartbeat_timeout    │
        │                                   │
        │   3. 存储映射:                    │
        │      session:conn:{connID}        │
        │      → phyID                      │
        │      TTL: 2x heartbeat_timeout    │
        │                                   │
        │   4. 添加到服务器连接集合:        │
        │      session:server:{serverID}    │
        │      :conns (Set) → connID        │
        │                                   │
        │   5. 本地缓存:                    │
        │      localConn[connID]            │
        │      → connContext                │
        └──────────┬────────────────────────┘
                   ↓
        ┌───────────────────────────────────┐
        │   后续心跳                        │
        │   (每 5-30 秒)                    │
        └──────────┬────────────────────────┘
                   ↓
        ┌───────────────────────────────────┐
        │   sess.OnHeartbeat(phyID, now)    │
        │                                   │
        │   更新:                           │
        │   session:device:{phyID}.lastSeen │
        │   = now                           │
        └──────────┬────────────────────────┘
                   ↓
        ┌───────────────────────────────────┐
        │   设备断开 TCP                    │
        │   (或 TCP 读取超时)               │
        └──────────┬────────────────────────┘
                   ↓
        ┌───────────────────────────────────┐
        │   ConnContext.Done() 信号         │
        │   触发清理 goroutine              │
        └──────────┬────────────────────────┘
                   ↓
        ┌───────────────────────────────────┐
        │   sess.UnbindByPhy(phyID)         │
        │                                   │
        │   1. 获取会话数据                 │
        │   2. 从本地缓存删除               │
        │   3. 从 Redis 删除:               │
        │      session:conn:{connID}        │
        │      session:device:{phyID}       │
        │   4. 从服务器连接集合移除         │
        └──────────┬────────────────────────┘
                   ↓
        ┌───────────────────────────────────┐
        │   sess.OnTCPClosed(phyID, now)    │
        │                                   │
        │   记录 TCP 断开事件:              │
        │   session:device:{phyID}          │
        │   .lastTCPDown = now              │
        │   (用于加权策略)                  │
        └───────────────────────────────────┘
```

---

## 5. 多阶段启动序列

```
                      启动
                        ↓
            ╔═══════════════════════════╗
            ║  阶段 1: 基础设置         ║
            ╠═══════════════════════════╣
            ║ • 指标注册表              ║
            ║ • 就绪跟踪器              ║
            ║ • ServerID 生成           ║
            ╚═════════════╤═════════════╝
                         ↓
            ╔═══════════════════════════╗
            ║  阶段 2: Redis 客户端     ║  ← 必需
            ╠═══════════════════════════╣
            ║ • 连接到 Redis            ║
            ║ • 无法连接时快速失败      ║
            ╚═════════════╤═════════════╝
                         ↓
            ╔═══════════════════════════╗
            ║  阶段 3: 会话管理器       ║
            ╠═══════════════════════════╣
            ║ • 创建 RedisManager       ║
            ║ • 加载 WeightedPolicy     ║
            ╚═════════════╤═════════════╝
                         ↓
            ╔═══════════════════════════╗
            ║  阶段 4: 数据库           ║  ← 必需
            ╠═══════════════════════════╣
            ║ • 连接到 PostgreSQL       ║
            ║ • 运行迁移                ║
            ║ • 无法连接时快速失败      ║
            ║ • 设置数据库就绪标志      ║
            ╚═════════════╤═════════════╝
                         ↓
            ╔═══════════════════════════╗
            ║  阶段 5: 处理器           ║
            ╠═══════════════════════════╣
            ║ • 创建 Repository         ║
            ║ • 加载 BKV 原因映射       ║
            ║ • 创建 Pusher             ║
            ║ • 创建 EventQueue         ║
            ║ • 创建 OutboundAdapter    ║
            ║ • 初始化 AP3000/BKV       ║
            ╚═════════════╤═════════════╝
                         ↓
            ╔═══════════════════════════╗
            ║  阶段 6: HTTP 服务器      ║ (后台)
            ╠═══════════════════════════╣
            ║ • 设置路由                ║
            ║ • 注册健康检查            ║
            ║ • 启动监听器              ║
            ║ • Go func (非阻塞)        ║
            ╚═════════════╤═════════════╝
                         ↓
            ╔═══════════════════════════╗
            ║  阶段 7: 工作线程         ║ (后台)
            ╠═══════════════════════════╣
            ║ • RedisWorker (轮询)      ║
            ║ • EventQueueWorkers       ║
            ║ • OrderMonitor            ║
            ║ • PortStatusSyncer        ║
            ║ • 全部作为 goroutines     ║
            ╚═════════════╤═════════════╝
                         ↓
            ╔═══════════════════════════╗
            ║  阶段 8: TCP 服务器       ║  ← 最后!
            ╠═══════════════════════════╣  (阻塞)
            ║ • 创建监听器              ║
            ║ • 安装处理器              ║
            ║ • 开始接受连接            ║
            ║ • 设置 TCP 就绪标志       ║
            ║ • 添加健康检查器          ║
            ╚═════════════╤═════════════╝
                         ↓
            ╔═══════════════════════════╗
            ║  所有服务就绪!            ║
            ║  接受连接                 ║
            ║  准备处理                 ║
            ╚═════════════╤═════════════╝
                         ↓
            ┌─────────────────────────┐
            │ 等待 SIGTERM/SIGINT     │
            └────────────┬────────────┘
                         ↓
            ╔═══════════════════════════╗
            ║  阶段 9: 关闭             ║
            ╠═══════════════════════════╣
            ║ • 停止 HTTP (10秒超时)    ║
            ║ • 停止 TCP (10秒超时)     ║
            ║ • 清理 Redis 会话         ║
            ║ • 关闭数据库连接          ║
            ╚═════════════╤═════════════╝
                         ↓
                      已停止
```

---

## 6. 协议检测和分发

```
    原始 TCP 流
           ↓
    前 N 个字节
           ↓
    ┌──────────────────────────────────────┐
    │  Mux.BindToConn.onRead() (首次调用)  │
    ├──────────────────────────────────────┤
    │                                      │
    │  prefix = 前 8 字节                  │
    │                                      │
    │  for each adapter:                   │
    │    if adapter.Sniff(prefix):         │
    │      找到 → 分发到此适配器           │
    │      恢复正常超时                    │
    │      break                           │
    │                                      │
    │  if not found:                       │
    │    尝试所有适配器 (回退)             │
    │                                      │
    └──────────┬───────────────────────────┘
               ↓
    ┌──────────────────────────────┐
    │  Sniff() 检查                │
    ├──────────────────────────────┤
    │                              │
    │  AP3000Adapter.Sniff():      │
    │  - 检查: b[0]==0x44 AND      │
    │           b[1]==0x22 AND     │
    │           b[2]==0x4E         │
    │  - 返回 true/false           │
    │                              │
    │  BKVAdapter.Sniff():         │
    │  - 检查: b[0]==0xFC AND      │
    │     (b[1]==0xFE OR b[1]==0xFF)│
    │  - 返回 true/false           │
    │                              │
    └──────────┬───────────────────┘
               ↓
    ┌──────────────────────────────┐
    │  设置永久处理器              │
    ├──────────────────────────────┤
    │                              │
    │  handler = func(p []byte) {  │
    │    adapter.ProcessBytes(p)   │
    │  }                           │
    │                              │
    │  (从现在开始，所有字节       │
    │   都只发送到此处理器)        │
    │                              │
    └──────────┬───────────────────┘
               ↓
    ┌──────────────────────────────┐
    │  后续字节                    │
    ├──────────────────────────────┤
    │                              │
    │  handler(p []byte)           │
    │  → adapter.ProcessBytes(p)   │
    │                              │
    │  不再需要嗅探或              │
    │  切换适配器                  │
    │                              │
    └──────────────────────────────┘
```

---

## 7. Redis 存储架构

```
┌────────────────────────────────────────────────────────────┐
│                    REDIS 存储架构                          │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  会话管理:                                                 │
│  ┌──────────────────────────────────────────────────────┐ │
│  │ session:device:{phyID}  (String → JSON)              │ │
│  │ {                                                     │ │
│  │   "phy_id": "GW001",                                 │ │
│  │   "conn_id": "uuid-...",                             │ │
│  │   "server_id": "server-uuid",                        │ │
│  │   "last_seen": "2025-11-10T01:39:00Z",              │ │
│  │   "last_tcp_down": null,                             │ │
│  │   "last_ack_timeout": null                           │ │
│  │ }                                                     │ │
│  │ TTL: 2 × heartbeat_timeout                           │ │
│  └──────────────────────────────────────────────────────┘ │
│                                                            │
│  session:conn:{connID}  (String → phyID)                  │
│  "GW001"                                                  │
│  TTL: 2 × heartbeat_timeout                              │
│                                                            │
│  session:server:{serverID}:conns  (Set of connIDs)        │
│  {conn-uuid-1, conn-uuid-2, ...}                          │
│  (无 TTL - 手动维护)                                      │
│                                                            │
│  ────────────────────────────────────────────────────────│
│                                                            │
│  出站队列:                                                 │
│  ┌──────────────────────────────────────────────────────┐ │
│  │ outbound:queue  (有序集合)                           │ │
│  │ (score, member) 对:                                  │ │
│  │                                                       │ │
│  │ score = priority * 1e12 + unixnano                   │ │
│  │ member = "msg_id:JSON_MESSAGE_DATA"                  │ │
│  │                                                       │ │
│  │ 示例:                                                 │ │
│  │ (1e12 + 1699589940123456789,                         │ │
│  │  "msg_1:{...}")                                       │ │
│  │                                                       │ │
│  │ 操作:                                                 │ │
│  │ - ZADD: 入队新消息                                   │ │
│  │ - ZPOPMIN: 出队 (原子操作)                           │ │
│  │ - ZCARD: 获取长度                                    │ │
│  └──────────────────────────────────────────────────────┘ │
│                                                            │
│  outbound:processing:{phyID}  (哈希)                      │ │
│  {                                                         │ │
│    "msg_id_1": "{...message_json...}",                    │ │
│    "msg_id_2": "{...message_json...}"                     │ │
│  }                                                         │ │
│  TTL: 2 × 消息超时 (防止消息卡住)                │ │
│                                                            │
│  outbound:dead  (列表)                                    │ │
│  [                                                         │ │
│    "{message: {...}, error: '...', failed_at: ...}",     │ │
│    ...                                                     │ │
│  ]                                                         │ │
│  (无 TTL - 累积直到手动清理)                              │ │
│                                                            │
│  ────────────────────────────────────────────────────────│
│                                                            │
│  事件管理 (可选):                                         │ │
│  ┌──────────────────────────────────────────────────────┐ │
│  │ event:queue:{type}  (列表)                           │ │
│  │ event:dedup:{hash}  (String with TTL)                │ │
│  │                                                       │ │
│  │ (如果启用第三方事件集成)                             │ │
│  └──────────────────────────────────────────────────────┘ │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

---

## 8. 错误处理和重试流程

```
    消息入队
           ↓
    ┌─────────────────────────────────┐
    │  检查队列长度                   │
    ├─────────────────────────────────┤
    │  len ≤ 200: 继续                │
    │  200 < len ≤ 500:               │
    │    拒绝优先级 > 5               │
    │  500 < len ≤ 1000:              │
    │    拒绝优先级 > 2               │
    │  len > 1000:                    │
    │    拒绝优先级 > 1               │
    └────────┬────────────────────────┘
             ↓
    入队到 Redis
             ↓
    RedisWorker 出队
             ↓
    ┌─────────────────────────────────┐
    │  获取连接                       │
    ├─────────────────────────────────┤
    │  sess.GetConn(phyID)             │
    │                                 │
    │  返回 nil 如果:                 │
    │  • 设备不在会话中               │
    │  • ServerID 不匹配              │
    │  • 心跳超时                     │
    │  • 连接不在缓存中               │
    └────────┬────────────────────────┘
             ↓
    ┌──────────────────┐
    │  连接可用?       │
    └────┬─────────┬──┘
         │         │
        是         否
         │         │
         ↓         ↓
    ┌────────┐  ┌──────────────────┐
    │ 写入   │  │ 标记失败         │
    │ 帧     │  │                  │
    └────┬───┘  │ retries++        │
         │      │                  │
    ┌────┴──────┴──────────────────┐
    │ 重试次数 < MaxRetry?         │
    └────┬──────────────┬───────────┘
         │              │
        是              否
         │              │
         ↓              ↓
    ┌─────────┐  ┌──────────────┐
    │ 重新入队 │  │ 移至死信队列 │
    │ (降低    │  │ (死信队列)   │
    │  优先级) │  │ (LLEN 增长)  │
    └─────────┘  └──────────────┘
         ↓
    记录警告:
    "消息已移至死信队列"
         ↓
    需要手动审查
    (死信队列需要清理)
```
