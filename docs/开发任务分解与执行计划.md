# å¼€å‘ä»»åŠ¡åˆ†è§£ä¸æ‰§è¡Œè®¡åˆ’

**åŸºäºæ·±åº¦ä¸šåŠ¡åˆ†æçš„å…·ä½“å¼€å‘æŒ‡å¯¼**  
**æ›´æ–°æ—¶é—´**: 2025-01-13  
**æ‰§è¡Œå‘¨æœŸ**: 9å‘¨è¯¦ç»†è§„åˆ’

## ğŸ¯ æ•´ä½“æ‰§è¡Œç­–ç•¥

### å¼€å‘åŸåˆ™
1. **æœ€å°å¯ç”¨äº§å“(MVP)ä¼˜å…ˆ**: ä¼˜å…ˆå®ç°æ ¸å¿ƒä¸šåŠ¡æµç¨‹
2. **å‘åå…¼å®¹**: æ‰€æœ‰æ–°åŠŸèƒ½ä¸å½±å“ç°æœ‰ç¨³å®šåŠŸèƒ½
3. **æ¸è¿›å¼äº¤ä»˜**: æ¯å‘¨äº¤ä»˜å¯ç”¨åŠŸèƒ½ï¼Œæ”¯æŒå¢é‡éƒ¨ç½²
4. **æµ‹è¯•é©±åŠ¨**: å…ˆå†™æµ‹è¯•ï¼Œç¡®ä¿è´¨é‡å’Œå›å½’éªŒè¯

### æŠ€æœ¯æ¶æ„å†³ç­–
- **APIç‰ˆæœ¬**: æ–°å¢ `/api/v1/third/` è·¯ç”±ï¼Œä¸ç°æœ‰APIå¹¶å­˜
- **æ•°æ®åº“**: æ‰©å±•ç°æœ‰è¡¨ç»“æ„ï¼Œä¸ç ´åç°æœ‰æ•°æ®
- **ç¼“å­˜ç­–ç•¥**: Redisé›†ç¾¤ï¼Œæ”¯æŒçƒ­ç‚¹æ•°æ®ç¼“å­˜
- **äº‹ä»¶é©±åŠ¨**: åŸºäºç°æœ‰thirdpartyæ¨é€æœºåˆ¶æ‰©å±•

## ğŸ“… è¯¦ç»†å¼€å‘è®¡åˆ’

### Week 1: åŸºç¡€è®¾æ–½å’ŒAPIæ¡†æ¶ (1æœˆ13æ—¥-1æœˆ19æ—¥)

#### Day 1-2: é¡¹ç›®å‡†å¤‡å’Œæ•°æ®æ¨¡å‹è®¾è®¡
**ç›®æ ‡**: å»ºç«‹å¼€å‘åŸºç¡€å’Œæ•°æ®ç»“æ„

**å…·ä½“ä»»åŠ¡**:
```bash
# 1. åˆ›å»ºå¼€å‘åˆ†æ”¯
git checkout -b feature/third-party-api-enhancement
git push -u origin feature/third-party-api-enhancement

# 2. ä¾èµ–ç®¡ç†
go mod tidy
go get github.com/go-playground/validator/v10  # APIå‚æ•°éªŒè¯
go get github.com/go-redis/redis/v8            # Redisç¼“å­˜
go get github.com/stretchr/testify             # æµ‹è¯•æ¡†æ¶

# 3. æ•°æ®åº“è¿ç§»å‡†å¤‡
mkdir -p db/migrations/business_api
```

**æ•°æ®åº“æ‰©å±•è®¾è®¡**:
```sql
-- db/migrations/005_business_api_up.sql

-- æ‰©å±•è®¢å•è¡¨æ”¯æŒç¬¬ä¸‰æ–¹ä¸šåŠ¡
ALTER TABLE orders ADD COLUMN IF NOT EXISTS third_party_order_no VARCHAR(100);
ALTER TABLE orders ADD COLUMN IF NOT EXISTS third_party_user_id VARCHAR(100);  
ALTER TABLE orders ADD COLUMN IF NOT EXISTS session_id VARCHAR(100);
ALTER TABLE orders ADD COLUMN IF NOT EXISTS api_request_data JSONB;
ALTER TABLE orders ADD COLUMN IF NOT EXISTS auto_stop_conditions JSONB;

-- åˆ›å»ºå”¯ä¸€ç´¢å¼•
CREATE UNIQUE INDEX IF NOT EXISTS idx_orders_third_party_order_no ON orders(third_party_order_no) WHERE third_party_order_no IS NOT NULL;
CREATE UNIQUE INDEX IF NOT EXISTS idx_orders_session_id ON orders(session_id) WHERE session_id IS NOT NULL;

-- APIè¯·æ±‚æ—¥å¿—è¡¨
CREATE TABLE IF NOT EXISTS api_request_logs (
    id BIGSERIAL PRIMARY KEY,
    request_id VARCHAR(100) UNIQUE NOT NULL,
    method VARCHAR(10) NOT NULL,
    endpoint VARCHAR(200) NOT NULL,
    device_phy_id VARCHAR(50),
    third_party_order_no VARCHAR(100),
    client_id VARCHAR(50),
    request_body JSONB,
    response_body JSONB,
    status_code INT,
    duration_ms INT,
    client_ip VARCHAR(45),
    user_agent VARCHAR(500),
    error_message TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- å……ç”µä¼šè¯æ‰©å±•è¡¨
CREATE TABLE IF NOT EXISTS charging_sessions (
    id BIGSERIAL PRIMARY KEY,
    session_id VARCHAR(100) UNIQUE NOT NULL,
    order_id BIGINT REFERENCES orders(id),
    device_id BIGINT REFERENCES devices(id),
    port_no INT NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    realtime_data JSONB,
    progress_data JSONB,
    last_update TIMESTAMP DEFAULT NOW(),
    created_at TIMESTAMP DEFAULT NOW()
);

-- APIå®¢æˆ·ç«¯ç®¡ç†è¡¨
CREATE TABLE IF NOT EXISTS api_clients (
    id BIGSERIAL PRIMARY KEY,
    client_id VARCHAR(50) UNIQUE NOT NULL,
    client_name VARCHAR(100) NOT NULL,
    api_key VARCHAR(100) UNIQUE NOT NULL,
    secret VARCHAR(100) NOT NULL,
    permissions JSONB,
    rate_limit_per_minute INT DEFAULT 1000,
    ip_whitelist JSONB,
    status SMALLINT DEFAULT 1,
    last_used_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- äº‹ä»¶æ¨é€è®°å½•è¡¨
CREATE TABLE IF NOT EXISTS event_push_logs (
    id BIGSERIAL PRIMARY KEY,
    event_id VARCHAR(100) UNIQUE NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    device_phy_id VARCHAR(50),
    session_id VARCHAR(100),
    payload JSONB,
    push_url VARCHAR(500),
    status VARCHAR(20) DEFAULT 'pending',
    http_status_code INT,
    response_body TEXT,
    retry_count INT DEFAULT 0,
    next_retry_at TIMESTAMP,
    completed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);

-- æ·»åŠ ç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢
CREATE INDEX IF NOT EXISTS idx_api_request_logs_device_time ON api_request_logs(device_phy_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_charging_sessions_device_port ON charging_sessions(device_id, port_no);
CREATE INDEX IF NOT EXISTS idx_event_push_logs_status_retry ON event_push_logs(status, next_retry_at) WHERE status = 'pending';
```

#### Day 3-4: APIæ¡†æ¶å®ç°
**ç›®æ ‡**: å»ºç«‹ç»Ÿä¸€çš„APIåŸºç¡€è®¾æ–½

**é¡¹ç›®ç»“æ„**:
```
internal/
â”œâ”€â”€ api/
â”‚   â””â”€â”€ v1/
â”‚       â””â”€â”€ third/
â”‚           â”œâ”€â”€ middleware.go      # è®¤è¯ã€é™æµã€æ—¥å¿—ä¸­é—´ä»¶
â”‚           â”œâ”€â”€ charging.go        # å……ç”µæ§åˆ¶å¤„ç†å™¨
â”‚           â”œâ”€â”€ device.go          # è®¾å¤‡ç®¡ç†å¤„ç†å™¨
â”‚           â”œâ”€â”€ stats.go           # ç»Ÿè®¡åˆ†æå¤„ç†å™¨
â”‚           â”œâ”€â”€ batch.go           # æ‰¹é‡æ“ä½œå¤„ç†å™¨
â”‚           â”œâ”€â”€ response.go        # ç»Ÿä¸€å“åº”æ ¼å¼
â”‚           â”œâ”€â”€ validator.go       # è¯·æ±‚å‚æ•°éªŒè¯
â”‚           â”œâ”€â”€ models.go          # APIæ•°æ®æ¨¡å‹
â”‚           â””â”€â”€ routes.go          # è·¯ç”±æ³¨å†Œ
â”œâ”€â”€ business/
â”‚   â”œâ”€â”€ charging.go                # å……ç”µä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ device_mgmt.go            # è®¾å¤‡ç®¡ç†ä¸šåŠ¡
â”‚   â”œâ”€â”€ events.go                 # äº‹ä»¶å¤„ç†ä¸šåŠ¡
â”‚   â””â”€â”€ stats.go                  # ç»Ÿè®¡åˆ†æä¸šåŠ¡
â””â”€â”€ cache/
    â”œâ”€â”€ redis.go                  # Rediså®¢æˆ·ç«¯
    â””â”€â”€ strategy.go               # ç¼“å­˜ç­–ç•¥
```

**æ ¸å¿ƒä»£ç å®ç°**:
```go
// internal/api/v1/third/response.go
package third

import (
    "net/http"
    "time"
    "github.com/gin-gonic/gin"
)

type APIResponse struct {
    Code      int         `json:"code"`
    Message   string      `json:"message"`
    Data      interface{} `json:"data,omitempty"`
    RequestID string      `json:"request_id,omitempty"`
    Timestamp int64       `json:"timestamp"`
}

type PaginatedResponse struct {
    APIResponse
    Pagination *Pagination `json:"pagination,omitempty"`
}

type Pagination struct {
    Page     int   `json:"page"`
    Size     int   `json:"size"`
    Total    int64 `json:"total"`
    HasNext  bool  `json:"has_next"`
    HasPrev  bool  `json:"has_prev"`
}

// é”™è¯¯ç å®šä¹‰
const (
    CodeSuccess              = 0
    CodeInvalidRequest       = 1001
    CodeUnauthorized        = 1002
    CodeRateLimitExceeded   = 1003
    CodeDeviceNotFound      = 2001
    CodeDeviceOffline       = 2002
    CodePortNotAvailable    = 2003
    CodeSessionNotFound     = 2004
    CodeOrderExists         = 2005
    CodeCommandFailed       = 3001
    CodeDatabaseError       = 5001
    CodeInternalError       = 5002
)

var errorMessages = map[int]string{
    CodeSuccess:              "success",
    CodeInvalidRequest:       "invalid request parameters",
    CodeUnauthorized:        "unauthorized access",
    CodeRateLimitExceeded:   "rate limit exceeded",
    CodeDeviceNotFound:      "device not found",
    CodeDeviceOffline:       "device is offline",
    CodePortNotAvailable:    "port is not available",
    CodeSessionNotFound:     "charging session not found",
    CodeOrderExists:         "order already exists",
    CodeCommandFailed:       "device command failed",
    CodeDatabaseError:       "database operation failed",
    CodeInternalError:       "internal server error",
}

func RespondSuccess(c *gin.Context, data interface{}) {
    c.JSON(http.StatusOK, APIResponse{
        Code:      CodeSuccess,
        Message:   errorMessages[CodeSuccess],
        Data:      data,
        RequestID: getRequestID(c),
        Timestamp: time.Now().Unix(),
    })
}

func RespondError(c *gin.Context, code int, customMessage ...string) {
    message := errorMessages[code]
    if len(customMessage) > 0 && customMessage[0] != "" {
        message = customMessage[0]
    }
    
    statusCode := http.StatusOK // ä¸šåŠ¡é”™è¯¯ä»è¿”å›200ï¼Œé€šè¿‡codeåŒºåˆ†
    if code >= 5000 {
        statusCode = http.StatusInternalServerError
    }
    
    c.JSON(statusCode, APIResponse{
        Code:      code,
        Message:   message,
        RequestID: getRequestID(c),
        Timestamp: time.Now().Unix(),
    })
}

func RespondPaginated(c *gin.Context, data interface{}, total int64, page, size int) {
    pagination := &Pagination{
        Page:    page,
        Size:    size,
        Total:   total,
        HasNext: int64(page*size) < total,
        HasPrev: page > 1,
    }
    
    c.JSON(http.StatusOK, PaginatedResponse{
        APIResponse: APIResponse{
            Code:      CodeSuccess,
            Message:   errorMessages[CodeSuccess],
            Data:      data,
            RequestID: getRequestID(c),
            Timestamp: time.Now().Unix(),
        },
        Pagination: pagination,
    })
}

func getRequestID(c *gin.Context) string {
    if requestID, exists := c.Get("request_id"); exists {
        return requestID.(string)
    }
    return ""
}
```

#### Day 5: è®¤è¯å’Œä¸­é—´ä»¶
**ç›®æ ‡**: å®ç°APIå®‰å…¨å’Œè®¿é—®æ§åˆ¶

```go
// internal/api/v1/third/middleware.go
package third

import (
    "crypto/hmac"
    "crypto/sha256"
    "encoding/hex"
    "fmt"
    "strconv"
    "strings"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/go-redis/redis/v8"
    "go.uber.org/zap"
)

type AuthMiddleware struct {
    logger    *zap.Logger
    apiKeys   map[string]APIClient
    redis     *redis.Client
}

type APIClient struct {
    ClientID         string   `json:"client_id"`
    ClientName       string   `json:"client_name"`
    Secret           string   `json:"secret"`
    Permissions      []string `json:"permissions"`
    RateLimitPerMin  int      `json:"rate_limit_per_minute"`
    IPWhitelist      []string `json:"ip_whitelist"`
    Status           int      `json:"status"`
}

func NewAuthMiddleware(logger *zap.Logger, redis *redis.Client) *AuthMiddleware {
    return &AuthMiddleware{
        logger:  logger,
        redis:   redis,
        apiKeys: make(map[string]APIClient),
    }
}

func (m *AuthMiddleware) LoadAPIKeys(clients []APIClient) {
    for _, client := range clients {
        m.apiKeys[client.ClientID] = client
    }
}

func (m *AuthMiddleware) APIKeyAuth() gin.HandlerFunc {
    return func(c *gin.Context) {
        apiKey := c.GetHeader("X-API-Key")
        if apiKey == "" {
            RespondError(c, CodeUnauthorized, "missing API key")
            c.Abort()
            return
        }
        
        client, exists := m.apiKeys[apiKey]
        if !exists || client.Status != 1 {
            RespondError(c, CodeUnauthorized, "invalid API key")
            c.Abort()
            return
        }
        
        // IPç™½åå•æ£€æŸ¥
        if len(client.IPWhitelist) > 0 {
            clientIP := c.ClientIP()
            if !m.isIPAllowed(clientIP, client.IPWhitelist) {
                RespondError(c, CodeUnauthorized, "IP not allowed")
                c.Abort()
                return
            }
        }
        
        // ç­¾åéªŒè¯(å¯é€‰)
        if signature := c.GetHeader("X-Signature"); signature != "" {
            if !m.verifySignature(c, client.Secret, signature) {
                RespondError(c, CodeUnauthorized, "invalid signature")
                c.Abort()
                return
            }
        }
        
        c.Set("client_id", client.ClientID)
        c.Set("client_name", client.ClientName)
        c.Set("permissions", client.Permissions)
        c.Next()
    }
}

func (m *AuthMiddleware) RateLimit() gin.HandlerFunc {
    return func(c *gin.Context) {
        clientID := c.GetString("client_id")
        if clientID == "" {
            c.Next()
            return
        }
        
        client := m.apiKeys[clientID]
        if client.RateLimitPerMin <= 0 {
            c.Next()
            return
        }
        
        key := fmt.Sprintf("rate_limit:%s:%d", clientID, time.Now().Unix()/60)
        
        count, err := m.redis.Incr(c.Request.Context(), key).Result()
        if err != nil {
            m.logger.Error("rate limit check failed", zap.Error(err))
            c.Next()
            return
        }
        
        if count == 1 {
            m.redis.Expire(c.Request.Context(), key, time.Minute)
        }
        
        if count > int64(client.RateLimitPerMin) {
            RespondError(c, CodeRateLimitExceeded)
            c.Abort()
            return
        }
        
        c.Next()
    }
}

func (m *AuthMiddleware) RequestLogging() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        requestID := fmt.Sprintf("req_%d_%06d", start.Unix(), start.Nanosecond()%1000000)
        c.Set("request_id", requestID)
        
        c.Next()
        
        duration := time.Since(start)
        
        m.logger.Info("API request",
            zap.String("request_id", requestID),
            zap.String("method", c.Request.Method),
            zap.String("path", c.Request.URL.Path),
            zap.String("client_id", c.GetString("client_id")),
            zap.String("client_ip", c.ClientIP()),
            zap.Int("status", c.Writer.Status()),
            zap.Duration("duration", duration),
        )
    }
}

func (m *AuthMiddleware) verifySignature(c *gin.Context, secret, signature string) bool {
    timestamp := c.GetHeader("X-Timestamp")
    nonce := c.GetHeader("X-Nonce")
    
    if timestamp == "" || nonce == "" {
        return false
    }
    
    // æ£€æŸ¥æ—¶é—´æˆ³æœ‰æ•ˆæ€§(5åˆ†é’Ÿå†…)
    ts, err := strconv.ParseInt(timestamp, 10, 64)
    if err != nil || time.Now().Unix()-ts > 300 {
        return false
    }
    
    // æ„é€ å¾…ç­¾åå­—ç¬¦ä¸²
    method := c.Request.Method
    path := c.Request.URL.Path
    bodyHash := "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855" // empty body hash
    
    canonicalString := fmt.Sprintf("%s\n%s\n%s\n%s\n%s", method, path, timestamp, nonce, bodyHash)
    
    // è®¡ç®—HMAC-SHA256
    h := hmac.New(sha256.New, []byte(secret))
    h.Write([]byte(canonicalString))
    expectedSignature := hex.EncodeToString(h.Sum(nil))
    
    return hmac.Equal([]byte(signature), []byte(expectedSignature))
}

func (m *AuthMiddleware) isIPAllowed(clientIP string, whitelist []string) bool {
    for _, allowedIP := range whitelist {
        if clientIP == allowedIP || strings.HasPrefix(clientIP, allowedIP) {
            return true
        }
    }
    return false
}
```

**Week 1äº¤ä»˜æ ‡å‡†**:
- [ ] æ•°æ®åº“è¿ç§»è„šæœ¬å®Œæˆå¹¶æµ‹è¯•é€šè¿‡
- [ ] APIæ¡†æ¶å’Œä¸­é—´ä»¶å®ç°å®Œæˆ
- [ ] ç»Ÿä¸€å“åº”æ ¼å¼å’Œé”™è¯¯å¤„ç†
- [ ] è®¤è¯å’Œé™æµæœºåˆ¶å·¥ä½œæ­£å¸¸
- [ ] åŸºç¡€çš„å•å…ƒæµ‹è¯•è¦†ç›–

### Week 2: å……ç”µæ§åˆ¶APIå®ç° (1æœˆ20æ—¥-1æœˆ26æ—¥)

#### Day 1-2: å……ç”µå¯åŠ¨API
**ç›®æ ‡**: å®ç°æ ¸å¿ƒçš„å……ç”µå¯åŠ¨åŠŸèƒ½

```go
// internal/api/v1/third/charging.go
package third

import (
    "context"
    "fmt"
    "net/http"
    "time"
    
    "github.com/gin-gonic/gin"
    "github.com/go-playground/validator/v10"
    "go.uber.org/zap"
)

type ChargingHandler struct {
    logger      *zap.Logger
    repo        Repository
    business    ChargingService
    validator   *validator.Validate
}

type StartChargingRequest struct {
    PortNo              int                    `json:"port_no" binding:"required,min=1,max=8"`
    Mode                int                    `json:"mode" binding:"required,oneof=1 2 3"`
    TimeLimit           int                    `json:"time_limit,omitempty" binding:"omitempty,min=1,max=1440"`
    EnergyLimit         int                    `json:"energy_limit,omitempty" binding:"omitempty,min=1,max=1000"`
    PowerLimit          int                    `json:"power_limit,omitempty" binding:"omitempty,min=1000,max=120000"`
    ThirdPartyOrderNo   string                 `json:"third_party_order_no" binding:"required,min=8,max=100"`
    ThirdPartyUserID    string                 `json:"third_party_user_id,omitempty" binding:"omitempty,max=100"`
    NotifyInterval      int                    `json:"notify_interval,omitempty" binding:"omitempty,min=10,max=300"`
    AutoStopConditions  *AutoStopConditions    `json:"auto_stop_conditions,omitempty"`
}

type AutoStopConditions struct {
    LowPowerThreshold    int     `json:"low_power_threshold,omitempty"`
    MaxTemperature       int     `json:"max_temperature,omitempty"`
    VoltageRange         [2]int  `json:"voltage_range,omitempty"`
    MaxSessionDuration   int     `json:"max_session_duration,omitempty"`
}

type StartChargingResponse struct {
    SessionID           string    `json:"session_id"`
    InternalOrderID     int64     `json:"internal_order_id"`
    EstimatedStartTime  time.Time `json:"estimated_start_time"`
    CommandStatus       string    `json:"command_status"`
    DeviceResponseTimeout int    `json:"device_response_timeout"`
}

func NewChargingHandler(logger *zap.Logger, repo Repository, business ChargingService) *ChargingHandler {
    return &ChargingHandler{
        logger:    logger,
        repo:      repo,
        business:  business,
        validator: validator.New(),
    }
}

func (h *ChargingHandler) StartCharging(c *gin.Context) {
    var req StartChargingRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        h.logger.Warn("invalid request", zap.Error(err))
        RespondError(c, CodeInvalidRequest, err.Error())
        return
    }
    
    phyID := c.Param("phyId")
    clientID := c.GetString("client_id")
    requestID := c.GetString("request_id")
    
    // è®°å½•APIè¯·æ±‚
    h.logAPIRequest(c.Request.Context(), requestID, c.Request, &req, phyID, clientID)
    
    // ä¸šåŠ¡é€»è¾‘éªŒè¯
    result, err := h.business.StartCharging(c.Request.Context(), &StartChargingParams{
        DevicePhyID:        phyID,
        PortNo:             req.PortNo,
        Mode:               req.Mode,
        TimeLimit:          req.TimeLimit,
        EnergyLimit:        req.EnergyLimit,
        PowerLimit:         req.PowerLimit,
        ThirdPartyOrderNo:  req.ThirdPartyOrderNo,
        ThirdPartyUserID:   req.ThirdPartyUserID,
        ClientID:           clientID,
        RequestID:          requestID,
        NotifyInterval:     req.NotifyInterval,
        AutoStopConditions: req.AutoStopConditions,
    })
    
    if err != nil {
        h.logger.Error("start charging failed", 
            zap.String("device_phy_id", phyID),
            zap.String("order_no", req.ThirdPartyOrderNo),
            zap.Error(err),
        )
        
        switch err.(type) {
        case *DeviceNotFoundError:
            RespondError(c, CodeDeviceNotFound)
        case *DeviceOfflineError:
            RespondError(c, CodeDeviceOffline)
        case *PortNotAvailableError:
            RespondError(c, CodePortNotAvailable)
        case *OrderExistsError:
            RespondError(c, CodeOrderExists)
        default:
            RespondError(c, CodeInternalError, "å……ç”µå¯åŠ¨å¤±è´¥")
        }
        return
    }
    
    response := StartChargingResponse{
        SessionID:           result.SessionID,
        InternalOrderID:     result.OrderID,
        EstimatedStartTime:  result.EstimatedStartTime,
        CommandStatus:       "sent",
        DeviceResponseTimeout: 15,
    }
    
    h.logger.Info("charging started successfully",
        zap.String("session_id", result.SessionID),
        zap.String("device_phy_id", phyID),
        zap.Int64("order_id", result.OrderID),
    )
    
    RespondSuccess(c, response)
}

func (h *ChargingHandler) StopCharging(c *gin.Context) {
    var req StopChargingRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        RespondError(c, CodeInvalidRequest, err.Error())
        return
    }
    
    phyID := c.Param("phyId")
    clientID := c.GetString("client_id")
    requestID := c.GetString("request_id")
    
    result, err := h.business.StopCharging(c.Request.Context(), &StopChargingParams{
        DevicePhyID:        phyID,
        PortNo:             req.PortNo,
        ThirdPartyOrderNo:  req.ThirdPartyOrderNo,
        Reason:             req.Reason,
        ForceStop:          req.ForceStop,
        ClientID:           clientID,
        RequestID:          requestID,
    })
    
    if err != nil {
        h.handleError(c, err, "åœæ­¢å……ç”µå¤±è´¥")
        return
    }
    
    RespondSuccess(c, gin.H{
        "session_id": result.SessionID,
        "status": "stopping",
        "command_sent": result.CommandSent,
    })
}

func (h *ChargingHandler) GetChargingStatus(c *gin.Context) {
    phyID := c.Param("phyId")
    portNo := c.Query("port_no")
    includeRealtime := c.Query("include_realtime") == "true"
    
    if portNo == "" {
        RespondError(c, CodeInvalidRequest, "port_no is required")
        return
    }
    
    status, err := h.business.GetChargingStatus(c.Request.Context(), &GetChargingStatusParams{
        DevicePhyID:     phyID,
        PortNo:          parseInt(portNo),
        IncludeRealtime: includeRealtime,
    })
    
    if err != nil {
        h.handleError(c, err, "æŸ¥è¯¢å……ç”µçŠ¶æ€å¤±è´¥")
        return
    }
    
    RespondSuccess(c, status)
}

// ä¸šåŠ¡é€»è¾‘æ¥å£
type ChargingService interface {
    StartCharging(ctx context.Context, params *StartChargingParams) (*StartChargingResult, error)
    StopCharging(ctx context.Context, params *StopChargingParams) (*StopChargingResult, error)
    GetChargingStatus(ctx context.Context, params *GetChargingStatusParams) (*ChargingStatusResult, error)
}
```

#### Day 3-4: ä¸šåŠ¡é€»è¾‘å±‚å®ç°
**ç›®æ ‡**: å®ç°å……ç”µæ§åˆ¶çš„ä¸šåŠ¡é€»è¾‘

```go
// internal/business/charging.go
package business

import (
    "context"
    "fmt"
    "time"
    
    "go.uber.org/zap"
    "github.com/taoyao-code/iot-server/internal/outbound"
    "github.com/taoyao-code/iot-server/internal/protocol/ap3000"
    "github.com/taoyao-code/iot-server/internal/protocol/bkv"
)

type ChargingManager struct {
    logger      *zap.Logger
    repo        Repository
    outbound    *outbound.Worker
    session     SessionManager
    events      EventPublisher
}

func NewChargingManager(logger *zap.Logger, repo Repository, outbound *outbound.Worker, session SessionManager, events EventPublisher) *ChargingManager {
    return &ChargingManager{
        logger:   logger,
        repo:     repo,
        outbound: outbound,
        session:  session,
        events:   events,
    }
}

func (m *ChargingManager) StartCharging(ctx context.Context, params *StartChargingParams) (*StartChargingResult, error) {
    // 1. éªŒè¯è®¾å¤‡çŠ¶æ€
    device, err := m.repo.GetDeviceByPhyID(ctx, params.DevicePhyID)
    if err != nil {
        return nil, &DeviceNotFoundError{DevicePhyID: params.DevicePhyID}
    }
    
    if !m.session.IsOnline(params.DevicePhyID) {
        return nil, &DeviceOfflineError{DevicePhyID: params.DevicePhyID}
    }
    
    // 2. éªŒè¯ç«¯å£çŠ¶æ€
    port, err := m.repo.GetPortByDeviceAndNo(ctx, device.ID, params.PortNo)
    if err != nil || port.Status != 0 { // 0:ç©ºé—²
        return nil, &PortNotAvailableError{
            DevicePhyID: params.DevicePhyID,
            PortNo:      params.PortNo,
            CurrentStatus: port.Status,
        }
    }
    
    // 3. æ£€æŸ¥è®¢å•å”¯ä¸€æ€§
    if exists, _ := m.repo.OrderExistsByThirdPartyNo(ctx, params.ThirdPartyOrderNo); exists {
        return nil, &OrderExistsError{ThirdPartyOrderNo: params.ThirdPartyOrderNo}
    }
    
    // 4. ç”Ÿæˆä¼šè¯ID
    sessionID := m.generateSessionID()
    
    // 5. åˆ›å»ºè®¢å•è®°å½•
    order := &Order{
        DeviceID:           device.ID,
        PhyID:             params.DevicePhyID,
        PortNo:            params.PortNo,
        ThirdPartyOrderNo: params.ThirdPartyOrderNo,
        ThirdPartyUserID:  params.ThirdPartyUserID,
        SessionID:         sessionID,
        Mode:              params.Mode,
        TimeLimit:         params.TimeLimit,
        EnergyLimit:       params.EnergyLimit,
        PowerLimit:        params.PowerLimit,
        Status:            1, // è¿›è¡Œä¸­
        RequestSource:     "api",
        APIRequestData:    params.ToJSON(),
        AutoStopConditions: params.AutoStopConditions,
        ClientID:          params.ClientID,
        RequestID:         params.RequestID,
    }
    
    if err := m.repo.CreateOrder(ctx, order); err != nil {
        m.logger.Error("failed to create order", zap.Error(err))
        return nil, fmt.Errorf("åˆ›å»ºè®¢å•å¤±è´¥: %w", err)
    }
    
    // 6. åˆ›å»ºå……ç”µä¼šè¯è®°å½•
    session := &ChargingSession{
        SessionID: sessionID,
        OrderID:   order.ID,
        DeviceID:  device.ID,
        PortNo:    params.PortNo,
        Status:    "pending",
        StartTime: time.Now(),
    }
    
    if err := m.repo.CreateChargingSession(ctx, session); err != nil {
        m.logger.Error("failed to create charging session", zap.Error(err))
        // ç»§ç»­æ‰§è¡Œï¼Œä¸å½±å“ä¸»æµç¨‹
    }
    
    // 7. å‘é€è®¾å¤‡æ§åˆ¶æŒ‡ä»¤
    commandSent, err := m.sendChargingCommand(device, params, order.ID)
    if err != nil {
        // æ›´æ–°è®¢å•çŠ¶æ€ä¸ºå¤±è´¥
        order.Status = 3 // å¼‚å¸¸
        m.repo.UpdateOrder(ctx, order)
        
        return nil, &CommandFailedError{
            DevicePhyID: params.DevicePhyID,
            Reason:      err.Error(),
        }
    }
    
    // 8. å‘é€å……ç”µå¯åŠ¨äº‹ä»¶
    if commandSent {
        go m.publishChargingStartedEvent(sessionID, params, order)
    }
    
    return &StartChargingResult{
        SessionID:          sessionID,
        OrderID:            order.ID,
        EstimatedStartTime: time.Now().Add(3 * time.Second),
        CommandSent:        commandSent,
    }, nil
}

func (m *ChargingManager) sendChargingCommand(device *Device, params *StartChargingParams, orderID int64) (bool, error) {
    switch device.Protocol {
    case "ap3000":
        return m.sendAP3000ChargingCommand(device.PhyID, params, orderID)
    case "bkv":
        return m.sendBKVChargingCommand(device.PhyID, params, orderID)
    case "gn":
        return m.sendGNChargingCommand(device.PhyID, params, orderID)
    default:
        return false, fmt.Errorf("unsupported protocol: %s", device.Protocol)
    }
}

func (m *ChargingManager) sendAP3000ChargingCommand(phyID string, params *StartChargingParams, orderID int64) (bool, error) {
    // æ„é€ AP3000åè®®çš„82å·æŒ‡ä»¤
    payload := ap3000.Build82Command(&ap3000.Command82{
        PortNo:      params.PortNo,
        Switch:      1, // å¼€å¯
        Mode:        params.Mode,
        TimeLimit:   params.TimeLimit,
        EnergyLimit: params.EnergyLimit,
        PowerLimit:  params.PowerLimit,
    })
    
    // åŠ å…¥å‡ºç«™é˜Ÿåˆ—
    correlationID := fmt.Sprintf("charging_start_%d", orderID)
    _, err := m.repo.EnqueueOutboxIdempotent(
        context.Background(),
        getDeviceIDByPhyID(phyID), // éœ€è¦å®ç°è¿™ä¸ªè¾…åŠ©å‡½æ•°
        &phyID,
        &params.PortNo,
        82, // AP3000å……ç”µæ§åˆ¶æŒ‡ä»¤
        payload,
        10, // é«˜ä¼˜å…ˆçº§
        correlationID,
        nil,
        15, // 15ç§’è¶…æ—¶
    )
    
    return err == nil, err
}

func (m *ChargingManager) publishChargingStartedEvent(sessionID string, params *StartChargingParams, order *Order) {
    event := &ChargingStartedEvent{
        EventID:           m.generateEventID(),
        SessionID:         sessionID,
        DevicePhyID:       params.DevicePhyID,
        PortNo:            params.PortNo,
        ThirdPartyOrderNo: params.ThirdPartyOrderNo,
        Mode:              params.Mode,
        TimeLimit:         params.TimeLimit,
        EnergyLimit:       params.EnergyLimit,
        EstimatedEndTime:  calculateEstimatedEndTime(params),
        Timestamp:         time.Now(),
    }
    
    if err := m.events.PublishChargingStarted(event); err != nil {
        m.logger.Error("failed to publish charging started event", 
            zap.String("session_id", sessionID),
            zap.Error(err),
        )
    }
}

// é”™è¯¯ç±»å‹å®šä¹‰
type DeviceNotFoundError struct {
    DevicePhyID string
}

func (e *DeviceNotFoundError) Error() string {
    return fmt.Sprintf("device not found: %s", e.DevicePhyID)
}

type DeviceOfflineError struct {
    DevicePhyID string
}

func (e *DeviceOfflineError) Error() string {
    return fmt.Sprintf("device is offline: %s", e.DevicePhyID)
}

type PortNotAvailableError struct {
    DevicePhyID   string
    PortNo        int
    CurrentStatus int
}

func (e *PortNotAvailableError) Error() string {
    return fmt.Sprintf("port %d of device %s is not available (status: %d)", 
        e.PortNo, e.DevicePhyID, e.CurrentStatus)
}
```

#### Day 5: äº‹ä»¶æ¨é€å®ç°
**ç›®æ ‡**: å®ç°å…³é”®ä¸šåŠ¡äº‹ä»¶çš„æ¨é€

```go
// internal/business/events.go
package business

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
    
    "go.uber.org/zap"
    "github.com/taoyao-code/iot-server/internal/thirdparty"
)

type EventPublisher struct {
    logger  *zap.Logger
    pusher  *thirdparty.Pusher
    pushURL string
    repo    Repository
}

type ChargingStartedEvent struct {
    EventID           string    `json:"event_id"`
    SessionID         string    `json:"session_id"`
    DevicePhyID       string    `json:"device_phy_id"`
    PortNo            int       `json:"port_no"`
    ThirdPartyOrderNo string    `json:"third_party_order_no"`
    Mode              int       `json:"mode"`
    TimeLimit         int       `json:"time_limit"`
    EnergyLimit       int       `json:"energy_limit"`
    EstimatedEndTime  time.Time `json:"estimated_end_time"`
    Timestamp         time.Time `json:"timestamp"`
}

func NewEventPublisher(logger *zap.Logger, pusher *thirdparty.Pusher, pushURL string, repo Repository) *EventPublisher {
    return &EventPublisher{
        logger:  logger,
        pusher:  pusher,
        pushURL: pushURL,
        repo:    repo,
    }
}

func (p *EventPublisher) PublishChargingStarted(event *ChargingStartedEvent) error {
    payload := map[string]interface{}{
        "event":          "charging.started",
        "event_id":       event.EventID,
        "device_phy_id":  event.DevicePhyID,
        "timestamp":      event.Timestamp.Unix(),
        "nonce":          generateNonce(),
        "data": map[string]interface{}{
            "session_id":           event.SessionID,
            "third_party_order_no": event.ThirdPartyOrderNo,
            "port_no":              event.PortNo,
            "mode":                 event.Mode,
            "time_limit":           event.TimeLimit,
            "energy_limit":         event.EnergyLimit,
            "estimated_end_time":   event.EstimatedEndTime.Format(time.RFC3339),
        },
    }
    
    // è®°å½•æ¨é€æ—¥å¿—
    logRecord := &EventPushLog{
        EventID:     event.EventID,
        EventType:   "charging.started",
        DevicePhyID: event.DevicePhyID,
        SessionID:   event.SessionID,
        Payload:     payload,
        PushURL:     p.pushURL,
        Status:      "pending",
    }
    
    if err := p.repo.CreateEventPushLog(context.Background(), logRecord); err != nil {
        p.logger.Error("failed to create event push log", zap.Error(err))
    }
    
    // å¼‚æ­¥æ¨é€
    go p.asyncPush(logRecord.ID, payload)
    
    return nil
}

func (p *EventPublisher) asyncPush(logID int64, payload map[string]interface{}) {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    statusCode, respBody, err := p.pusher.SendJSON(ctx, p.pushURL, payload)
    
    updateData := map[string]interface{}{
        "http_status_code": statusCode,
        "response_body":    string(respBody),
        "completed_at":     time.Now(),
    }
    
    if err != nil {
        updateData["status"] = "failed"
        updateData["retry_count"] = 1
        updateData["next_retry_at"] = time.Now().Add(30 * time.Second)
        
        p.logger.Error("event push failed", 
            zap.Int64("log_id", logID),
            zap.Error(err),
        )
    } else if statusCode >= 200 && statusCode < 300 {
        updateData["status"] = "success"
        
        p.logger.Info("event push succeeded", 
            zap.Int64("log_id", logID),
            zap.Int("status_code", statusCode),
        )
    } else {
        updateData["status"] = "failed"
        updateData["retry_count"] = 1
        updateData["next_retry_at"] = time.Now().Add(30 * time.Second)
        
        p.logger.Warn("event push failed with http error", 
            zap.Int64("log_id", logID),
            zap.Int("status_code", statusCode),
        )
    }
    
    p.repo.UpdateEventPushLog(context.Background(), logID, updateData)
}
```

**Week 2äº¤ä»˜æ ‡å‡†**:
- [ ] å……ç”µå¯åŠ¨/åœæ­¢APIå®Œæ•´å®ç°
- [ ] å……ç”µçŠ¶æ€æŸ¥è¯¢APIå®ç°
- [ ] ä¸ç°æœ‰åè®®å¤„ç†å™¨æ­£ç¡®é›†æˆ
- [ ] å…³é”®äº‹ä»¶æ¨é€æœºåˆ¶å·¥ä½œæ­£å¸¸
- [ ] é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•å®Œå–„
- [ ] APIé›†æˆæµ‹è¯•é€šè¿‡

### Week 3-9: åç»­å¼€å‘è®¡åˆ’æ¦‚è¦

**Week 3**: è®¾å¤‡ç®¡ç†APIå’Œæ‰¹é‡æ“ä½œ
**Week 4**: æ•°æ®ç»Ÿè®¡åˆ†æAPIåŸºç¡€ç‰ˆ
**Week 5**: äº‹ä»¶æ¨é€ç³»ç»Ÿå®Œå–„å’Œé‡è¯•æœºåˆ¶
**Week 6**: å‘Šè­¦è§„åˆ™å¼•æ“å®ç°
**Week 7**: å¤šæ¸ é“é€šçŸ¥ç³»ç»Ÿ
**Week 8**: è¿è¥åˆ†æAPIå’ŒDashboardæ•°æ®
**Week 9**: ç³»ç»Ÿé›†æˆæµ‹è¯•å’Œæ€§èƒ½ä¼˜åŒ–

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•
```bash
# æ¯ä¸ªåŠŸèƒ½æ¨¡å—éƒ½è¦æœ‰å•å…ƒæµ‹è¯•
go test ./internal/api/v1/third/...
go test ./internal/business/...
```

### é›†æˆæµ‹è¯•
```bash
# APIé›†æˆæµ‹è¯•è„šæœ¬
./scripts/test_charging_api.sh
./scripts/test_device_mgmt_api.sh
```

### æ€§èƒ½æµ‹è¯•
```bash
# å‹åŠ›æµ‹è¯•
hey -n 10000 -c 100 -H "X-API-Key: test_key" \
    http://localhost:8080/api/v1/third/devices
```

## ğŸ“Š é¡¹ç›®ç®¡ç†å’Œè·Ÿè¸ª

### æ¯å‘¨æ£€æŸ¥ç‚¹
- å‘¨ä¸€ï¼šåˆ¶å®šæœ¬å‘¨è¯¦ç»†ä»»åŠ¡
- å‘¨ä¸‰ï¼šè¿›åº¦æ£€æŸ¥å’Œé—®é¢˜è§£å†³
- å‘¨äº”ï¼šåŠŸèƒ½æ¼”ç¤ºå’Œä¸‹å‘¨è§„åˆ’

### è´¨é‡æ ‡å‡†
- ä»£ç è¦†ç›–ç‡ > 80%
- APIå“åº”æ—¶é—´ P95 < 100ms
- æ‰€æœ‰APIéƒ½æœ‰å®Œæ•´æ–‡æ¡£
- é”™è¯¯å¤„ç†è¦†ç›–æ‰€æœ‰è¾¹ç•Œæƒ…å†µ

### é£é™©æ§åˆ¶
- æ¯æ—¥ä»£ç å¤‡ä»½å’Œæ¨é€
- åŠŸèƒ½å¼€å…³æ§åˆ¶æ–°ç‰¹æ€§
- ç°åº¦å‘å¸ƒéªŒè¯
- å›æ»šæ–¹æ¡ˆå‡†å¤‡

---

**ç«‹å³å¼€å§‹**: æŒ‰ç…§Week 1çš„è¯¦ç»†ä»»åŠ¡å¼€å§‹æ‰§è¡Œï¼Œå»ºç«‹åšå®çš„æŠ€æœ¯åŸºç¡€åï¼Œåç»­åŠŸèƒ½å¼€å‘å°†æ›´åŠ é«˜æ•ˆã€‚