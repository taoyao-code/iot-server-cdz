# æŠ€æœ¯å®æ–½æŒ‡å—å’Œä»£ç ç¤ºä¾‹

æœ¬æ–‡æ¡£æä¾›å…³é”®æŠ€æœ¯ç»„ä»¶çš„å®æ–½æŒ‡å—å’Œä»£ç ç¤ºä¾‹ï¼Œå¸®åŠ©å¼€å‘å›¢é˜Ÿå¿«é€Ÿä¸Šæ‰‹ã€‚

## ğŸ” ç”¨æˆ·è®¤è¯ç³»ç»Ÿ

### JWTä¸­é—´ä»¶å®ç°
```go
// internal/auth/jwt.go
package auth

import (
    "time"
    "github.com/golang-jwt/jwt/v5"
    "github.com/gin-gonic/gin"
)

type JWTClaims struct {
    UserID   int64  `json:"user_id"`
    Username string `json:"username"`
    OrgID    int64  `json:"org_id"`
    jwt.RegisteredClaims
}

type JWTManager struct {
    secretKey     []byte
    tokenExpire   time.Duration
    refreshExpire time.Duration
}

func NewJWTManager(secret string, tokenExpire, refreshExpire time.Duration) *JWTManager {
    return &JWTManager{
        secretKey:     []byte(secret),
        tokenExpire:   tokenExpire,
        refreshExpire: refreshExpire,
    }
}

func (j *JWTManager) GenerateTokens(userID int64, username string, orgID int64) (accessToken, refreshToken string, err error) {
    now := time.Now()
    
    // Access Token
    claims := &JWTClaims{
        UserID:   userID,
        Username: username,
        OrgID:    orgID,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(now.Add(j.tokenExpire)),
            IssuedAt:  jwt.NewNumericDate(now),
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    accessToken, err = token.SignedString(j.secretKey)
    if err != nil {
        return "", "", err
    }
    
    // Refresh Token
    refreshClaims := &JWTClaims{
        UserID: userID,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(now.Add(j.refreshExpire)),
            IssuedAt:  jwt.NewNumericDate(now),
        },
    }
    
    refreshTokenObj := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
    refreshToken, err = refreshTokenObj.SignedString(j.secretKey)
    return
}

func (j *JWTManager) ParseToken(tokenString string) (*JWTClaims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &JWTClaims{}, func(token *jwt.Token) (interface{}, error) {
        return j.secretKey, nil
    })
    
    if err != nil {
        return nil, err
    }
    
    claims, ok := token.Claims.(*JWTClaims)
    if !ok || !token.Valid {
        return nil, jwt.ErrInvalidKey
    }
    
    return claims, nil
}

// Ginä¸­é—´ä»¶
func (j *JWTManager) AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(401, gin.H{"error": "missing authorization header"})
            c.Abort()
            return
        }
        
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        claims, err := j.ParseToken(tokenString)
        if err != nil {
            c.JSON(401, gin.H{"error": "invalid token"})
            c.Abort()
            return
        }
        
        // è®¾ç½®ç”¨æˆ·ä¸Šä¸‹æ–‡
        c.Set("user_id", claims.UserID)
        c.Set("username", claims.Username)
        c.Set("org_id", claims.OrgID)
        c.Next()
    }
}
```

### RBACæƒé™æ§åˆ¶
```go
// internal/auth/rbac.go
package auth

import (
    "github.com/casbin/casbin/v2"
    "github.com/gin-gonic/gin"
)

type RBACManager struct {
    enforcer *casbin.Enforcer
}

func NewRBACManager(modelPath, policyPath string) (*RBACManager, error) {
    enforcer, err := casbin.NewEnforcer(modelPath, policyPath)
    if err != nil {
        return nil, err
    }
    
    return &RBACManager{enforcer: enforcer}, nil
}

func (r *RBACManager) CheckPermission(userID int64, resource, action string) (bool, error) {
    return r.enforcer.Enforce(fmt.Sprintf("user_%d", userID), resource, action)
}

func (r *RBACManager) RequirePermission(resource, action string) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID, exists := c.Get("user_id")
        if !exists {
            c.JSON(401, gin.H{"error": "unauthorized"})
            c.Abort()
            return
        }
        
        allowed, err := r.CheckPermission(userID.(int64), resource, action)
        if err != nil || !allowed {
            c.JSON(403, gin.H{"error": "permission denied"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}

// RBACæ¨¡å‹æ–‡ä»¶ conf/rbac_model.conf
/*
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act
*/
```

## ğŸ’³ è®¡è´¹å¼•æ“å®ç°

### è®¡è´¹ç­–ç•¥æ¥å£
```go
// internal/billing/engine.go
package billing

import (
    "time"
    "encoding/json"
)

type BillingEngine struct {
    strategies map[int64]BillingStrategy
}

type BillingStrategy interface {
    Calculate(session *ChargingSession) (*BillingResult, error)
    Validate() error
}

type ChargingSession struct {
    SessionID    string
    DeviceID     string
    PortNo       int
    StartTime    time.Time
    EndTime      *time.Time
    KWH          float64
    UserID       int64
    StrategyID   int64
}

type BillingResult struct {
    TotalAmount    int64  // åˆ†ä¸ºå•ä½
    BreakdownItems []BillingItem
    Currency       string
}

type BillingItem struct {
    Type        string // "time", "energy", "service"
    Description string
    Quantity    float64
    UnitPrice   int64
    Amount      int64
}

// æŒ‰æ—¶é—´è®¡è´¹ç­–ç•¥
type TimeBillingStrategy struct {
    PricePerHour int64 `json:"price_per_hour"` // åˆ†/å°æ—¶
    MinCharge    int64 `json:"min_charge"`     // æœ€ä½æ”¶è´¹
}

func (t *TimeBillingStrategy) Calculate(session *ChargingSession) (*BillingResult, error) {
    if session.EndTime == nil {
        return nil, fmt.Errorf("session not completed")
    }
    
    duration := session.EndTime.Sub(session.StartTime)
    hours := duration.Hours()
    
    amount := int64(hours * float64(t.PricePerHour))
    if amount < t.MinCharge {
        amount = t.MinCharge
    }
    
    return &BillingResult{
        TotalAmount: amount,
        BreakdownItems: []BillingItem{
            {
                Type:        "time",
                Description: fmt.Sprintf("å……ç”µæ—¶é•¿ %.2f å°æ—¶", hours),
                Quantity:    hours,
                UnitPrice:   t.PricePerHour,
                Amount:      amount,
            },
        },
        Currency: "CNY",
    }, nil
}

// æŒ‰ç”µé‡è®¡è´¹ç­–ç•¥
type EnergyBillingStrategy struct {
    PricePerKWH int64 `json:"price_per_kwh"` // åˆ†/åº¦
    ServiceFee  int64 `json:"service_fee"`   // æœåŠ¡è´¹
}

func (e *EnergyBillingStrategy) Calculate(session *ChargingSession) (*BillingResult, error) {
    if session.EndTime == nil {
        return nil, fmt.Errorf("session not completed")
    }
    
    energyAmount := int64(session.KWH * float64(e.PricePerKWH))
    totalAmount := energyAmount + e.ServiceFee
    
    items := []BillingItem{
        {
            Type:        "energy",
            Description: fmt.Sprintf("ç”¨ç”µé‡ %.2f åº¦", session.KWH),
            Quantity:    session.KWH,
            UnitPrice:   e.PricePerKWH,
            Amount:      energyAmount,
        },
    }
    
    if e.ServiceFee > 0 {
        items = append(items, BillingItem{
            Type:        "service",
            Description: "æœåŠ¡è´¹",
            Quantity:    1,
            UnitPrice:   e.ServiceFee,
            Amount:      e.ServiceFee,
        })
    }
    
    return &BillingResult{
        TotalAmount:    totalAmount,
        BreakdownItems: items,
        Currency:       "CNY",
    }, nil
}

func (b *BillingEngine) CalculateBill(session *ChargingSession) (*BillingResult, error) {
    strategy, exists := b.strategies[session.StrategyID]
    if !exists {
        return nil, fmt.Errorf("billing strategy %d not found", session.StrategyID)
    }
    
    return strategy.Calculate(session)
}
```

## ğŸ“± å……ç”µä¸šåŠ¡API

### å……ç”µä¼šè¯ç®¡ç†
```go
// internal/api/v1/charging.go
package v1

import (
    "net/http"
    "strconv"
    "github.com/gin-gonic/gin"
    "github.com/taoyao-code/iot-server/internal/billing"
    "github.com/taoyao-code/iot-server/internal/storage/pg"
)

type ChargingHandler struct {
    repo    *pg.Repository
    billing *billing.BillingEngine
}

type StartChargingRequest struct {
    DevicePhyID   string `json:"device_phy_id" binding:"required"`
    PortNo        int    `json:"port_no" binding:"required"`
    ChargingMode  int    `json:"charging_mode"`  // 1:æŒ‰æ—¶é—´ 2:æŒ‰ç”µé‡
    TimeLimit     int    `json:"time_limit"`     // åˆ†é’Ÿ
    EnergyLimit   int    `json:"energy_limit"`   // kWh*100
    EstimatedAmount int64 `json:"estimated_amount"` // é¢„ä¼°é‡‘é¢(åˆ†)
}

type ChargingStatusResponse struct {
    SessionID       string    `json:"session_id"`
    Status          int       `json:"status"` // 1:è¿›è¡Œä¸­ 2:å·²å®Œæˆ 3:å¼‚å¸¸
    StartTime       time.Time `json:"start_time"`
    EndTime         *time.Time `json:"end_time,omitempty"`
    ElapsedTime     int       `json:"elapsed_time"` // ç§’
    CurrentPower    int       `json:"current_power"` // W
    ConsumedEnergy  int       `json:"consumed_energy"` // kWh*100
    CurrentAmount   int64     `json:"current_amount"` // å½“å‰è´¹ç”¨(åˆ†)
    EstimatedAmount int64     `json:"estimated_amount"` // é¢„ä¼°è´¹ç”¨(åˆ†)
}

func (h *ChargingHandler) StartCharging(c *gin.Context) {
    var req StartChargingRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    userID := c.GetInt64("user_id")
    
    // 1. éªŒè¯è®¾å¤‡çŠ¶æ€
    device, err := h.repo.GetDeviceByPhyID(c.Request.Context(), req.DevicePhyID)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "device not found"})
        return
    }
    
    // 2. æ£€æŸ¥ç«¯å£çŠ¶æ€
    port, err := h.repo.GetPortByDeviceAndNo(c.Request.Context(), device.ID, req.PortNo)
    if err != nil || port.Status != 0 { // 0:ç©ºé—²
        c.JSON(http.StatusConflict, gin.H{"error": "port not available"})
        return
    }
    
    // 3. åˆ›å»ºå……ç”µè®¢å•
    order := &pg.Order{
        DeviceID:            device.ID,
        PhyID:              req.DevicePhyID,
        PortNo:             req.PortNo,
        UserID:             userID,
        OrderNo:            generateOrderNo(),
        Status:             1, // è¿›è¡Œä¸­
        ChargingMode:       req.ChargingMode,
        TimeLimit:          req.TimeLimit,
        EnergyLimit:        req.EnergyLimit,
        EstimatedAmountCent: req.EstimatedAmount,
        StartTime:          time.Now(),
    }
    
    if err := h.repo.CreateOrder(c.Request.Context(), order); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create order"})
        return
    }
    
    // 4. å‘é€å¯åŠ¨æŒ‡ä»¤åˆ°è®¾å¤‡
    if err := h.sendStartCommand(device.PhyID, req.PortNo, req.ChargingMode, req.TimeLimit, req.EnergyLimit); err != nil {
        // å›æ»šè®¢å•çŠ¶æ€
        order.Status = 3 // å¼‚å¸¸
        h.repo.UpdateOrder(c.Request.Context(), order)
        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to start charging"})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "session_id": order.OrderNo,
        "status": "started",
        "estimated_amount": req.EstimatedAmount,
    })
}

func (h *ChargingHandler) StopCharging(c *gin.Context) {
    sessionID := c.Param("sessionId")
    userID := c.GetInt64("user_id")
    
    // 1. æŸ¥è¯¢è®¢å•
    order, err := h.repo.GetOrderByNo(c.Request.Context(), sessionID)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "session not found"})
        return
    }
    
    // 2. éªŒè¯ç”¨æˆ·æƒé™
    if order.UserID != userID {
        c.JSON(http.StatusForbidden, gin.H{"error": "permission denied"})
        return
    }
    
    // 3. æ£€æŸ¥è®¢å•çŠ¶æ€
    if order.Status != 1 {
        c.JSON(http.StatusConflict, gin.H{"error": "session not active"})
        return
    }
    
    // 4. å‘é€åœæ­¢æŒ‡ä»¤
    if err := h.sendStopCommand(order.PhyID, order.PortNo); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to stop charging"})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"status": "stopping"})
}

func (h *ChargingHandler) GetChargingStatus(c *gin.Context) {
    sessionID := c.Param("sessionId")
    
    order, err := h.repo.GetOrderByNo(c.Request.Context(), sessionID)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "session not found"})
        return
    }
    
    // è·å–å®æ—¶ç«¯å£çŠ¶æ€
    port, _ := h.repo.GetPortByDeviceAndNo(c.Request.Context(), order.DeviceID, order.PortNo)
    
    response := ChargingStatusResponse{
        SessionID:       order.OrderNo,
        Status:          order.Status,
        StartTime:       order.StartTime,
        EndTime:         order.EndTime,
        EstimatedAmount: order.EstimatedAmountCent,
    }
    
    if order.Status == 1 && order.StartTime != nil {
        elapsed := time.Since(*order.StartTime)
        response.ElapsedTime = int(elapsed.Seconds())
    }
    
    if port != nil {
        response.CurrentPower = port.PowerW
        response.ConsumedEnergy = order.KWH01 // å·²æ¶ˆè€—ç”µé‡*100
    }
    
    // è®¡ç®—å½“å‰è´¹ç”¨
    if order.Status == 1 {
        session := &billing.ChargingSession{
            SessionID:  order.OrderNo,
            DeviceID:   order.PhyID,
            PortNo:     order.PortNo,
            StartTime:  *order.StartTime,
            KWH:        float64(order.KWH01) / 100,
            UserID:     order.UserID,
            StrategyID: 1, // é»˜è®¤ç­–ç•¥
        }
        
        if result, err := h.billing.CalculateBill(session); err == nil {
            response.CurrentAmount = result.TotalAmount
        }
    }
    
    c.JSON(http.StatusOK, response)
}

func (h *ChargingHandler) sendStartCommand(phyID string, portNo, mode, timeLimit, energyLimit int) error {
    // è¿™é‡Œé›†æˆç°æœ‰çš„outboundç³»ç»Ÿ
    // æ„é€ 82å·æŒ‡ä»¤å¹¶åŠ å…¥å‡ºç«™é˜Ÿåˆ—
    return nil
}

func (h *ChargingHandler) sendStopCommand(phyID string, portNo int) error {
    // å‘é€åœæ­¢å……ç”µæŒ‡ä»¤
    return nil
}

func generateOrderNo() string {
    return fmt.Sprintf("CHG%d%06d", time.Now().Unix(), rand.Intn(1000000))
}
```

## ğŸ’° æ”¯ä»˜ç³»ç»Ÿé›†æˆ

### å¾®ä¿¡æ”¯ä»˜å°è£…
```go
// internal/payment/wechat.go
package payment

import (
    "crypto/md5"
    "encoding/xml"
    "fmt"
    "net/http"
    "sort"
    "strings"
    "time"
)

type WechatPay struct {
    AppID      string
    MerchantID string
    APIKey     string
    NotifyURL  string
}

type UnifiedOrderRequest struct {
    AppID          string `xml:"appid"`
    MchID          string `xml:"mch_id"`
    NonceStr       string `xml:"nonce_str"`
    Sign           string `xml:"sign"`
    Body           string `xml:"body"`
    OutTradeNo     string `xml:"out_trade_no"`
    TotalFee       int    `xml:"total_fee"`
    SpbillCreateIP string `xml:"spbill_create_ip"`
    NotifyURL      string `xml:"notify_url"`
    TradeType      string `xml:"trade_type"`
}

type UnifiedOrderResponse struct {
    ReturnCode string `xml:"return_code"`
    ReturnMsg  string `xml:"return_msg"`
    ResultCode string `xml:"result_code"`
    PrepayID   string `xml:"prepay_id"`
    CodeURL    string `xml:"code_url"`
}

func (w *WechatPay) CreateOrder(orderNo string, amount int64, description string) (*PaymentOrder, error) {
    req := &UnifiedOrderRequest{
        AppID:          w.AppID,
        MchID:          w.MerchantID,
        NonceStr:       generateNonce(),
        Body:           description,
        OutTradeNo:     orderNo,
        TotalFee:       int(amount), // å¾®ä¿¡æ”¯ä»˜ä»¥åˆ†ä¸ºå•ä½
        SpbillCreateIP: "127.0.0.1",
        NotifyURL:      w.NotifyURL,
        TradeType:      "NATIVE", // æ‰«ç æ”¯ä»˜
    }
    
    // ç”Ÿæˆç­¾å
    req.Sign = w.generateSign(req)
    
    // å‘é€è¯·æ±‚åˆ°å¾®ä¿¡
    resp, err := w.sendRequest("https://api.mch.weixin.qq.com/pay/unifiedorder", req)
    if err != nil {
        return nil, err
    }
    
    var wechatResp UnifiedOrderResponse
    if err := xml.Unmarshal(resp, &wechatResp); err != nil {
        return nil, err
    }
    
    if wechatResp.ReturnCode != "SUCCESS" || wechatResp.ResultCode != "SUCCESS" {
        return nil, fmt.Errorf("wechat pay error: %s", wechatResp.ReturnMsg)
    }
    
    return &PaymentOrder{
        OrderNo:   orderNo,
        Amount:    amount,
        Status:    "created",
        PayURL:    wechatResp.CodeURL,
        PrepayID:  wechatResp.PrepayID,
        CreatedAt: time.Now(),
    }, nil
}

func (w *WechatPay) HandleNotify(body []byte) (*PaymentResult, error) {
    var notify struct {
        ReturnCode    string `xml:"return_code"`
        ResultCode    string `xml:"result_code"`
        OutTradeNo    string `xml:"out_trade_no"`
        TransactionID string `xml:"transaction_id"`
        TotalFee      int    `xml:"total_fee"`
        TimeEnd       string `xml:"time_end"`
    }
    
    if err := xml.Unmarshal(body, &notify); err != nil {
        return nil, err
    }
    
    if notify.ReturnCode != "SUCCESS" || notify.ResultCode != "SUCCESS" {
        return nil, fmt.Errorf("payment failed")
    }
    
    return &PaymentResult{
        OrderNo:       notify.OutTradeNo,
        TransactionID: notify.TransactionID,
        Amount:        int64(notify.TotalFee),
        Status:        "success",
        PaidAt:        parseWechatTime(notify.TimeEnd),
    }, nil
}

func (w *WechatPay) generateSign(req interface{}) string {
    // å‚æ•°æŒ‰å­—å…¸åºæ’åºå¹¶æ‹¼æ¥
    params := structToMap(req)
    var keys []string
    for k := range params {
        if k != "sign" && params[k] != "" {
            keys = append(keys, k)
        }
    }
    sort.Strings(keys)
    
    var parts []string
    for _, k := range keys {
        parts = append(parts, fmt.Sprintf("%s=%s", k, params[k]))
    }
    
    signStr := strings.Join(parts, "&") + "&key=" + w.APIKey
    return strings.ToUpper(fmt.Sprintf("%x", md5.Sum([]byte(signStr))))
}
```

## ğŸ“Š æ•°æ®åº“è¿ç§»ç¤ºä¾‹

### ç”¨æˆ·ç®¡ç†è¡¨ç»“æ„
```sql
-- db/migrations/002_add_user_management.up.sql

-- ç”¨æˆ·è¡¨
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    phone VARCHAR(20) UNIQUE,
    email VARCHAR(100) UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    status SMALLINT DEFAULT 1, -- 1:æ­£å¸¸ 0:ç¦ç”¨
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- è§’è‰²è¡¨
CREATE TABLE roles (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    description TEXT,
    permissions JSONB, -- æƒé™åˆ—è¡¨
    created_at TIMESTAMP DEFAULT NOW()
);

-- ç”¨æˆ·è§’è‰²å…³è”è¡¨
CREATE TABLE user_roles (
    user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
    role_id BIGINT REFERENCES roles(id) ON DELETE CASCADE,
    created_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (user_id, role_id)
);

-- ç»„ç»‡è¡¨
CREATE TABLE organizations (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    parent_id BIGINT REFERENCES organizations(id),
    type VARCHAR(20) DEFAULT 'station', -- company/region/station
    address TEXT,
    location_lat DECIMAL(10, 7),
    location_lng DECIMAL(10, 7),
    created_at TIMESTAMP DEFAULT NOW()
);

-- ç”¨æˆ·ç»„ç»‡å…³è”è¡¨
CREATE TABLE user_organizations (
    user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
    org_id BIGINT REFERENCES organizations(id) ON DELETE CASCADE,
    role VARCHAR(20) DEFAULT 'member', -- admin/manager/member
    created_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (user_id, org_id)
);

-- æ‰©å±•ç°æœ‰è®¢å•è¡¨
ALTER TABLE orders ADD COLUMN user_id BIGINT REFERENCES users(id);
ALTER TABLE orders ADD COLUMN pricing_strategy_id BIGINT DEFAULT 1;
ALTER TABLE orders ADD COLUMN estimated_amount_cent BIGINT;
ALTER TABLE orders ADD COLUMN actual_amount_cent BIGINT;
ALTER TABLE orders ADD COLUMN charging_mode SMALLINT; -- 1:æŒ‰æ—¶é—´ 2:æŒ‰ç”µé‡

-- è®¡è´¹ç­–ç•¥è¡¨
CREATE TABLE pricing_strategies (
    id BIGSERIAL PRIMARY KEY,
    org_id BIGINT REFERENCES organizations(id),
    name VARCHAR(100) NOT NULL,
    type VARCHAR(20) NOT NULL, -- time/energy/tiered
    rules JSONB NOT NULL, -- è®¡è´¹è§„åˆ™é…ç½®
    effective_from TIMESTAMP DEFAULT NOW(),
    effective_to TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);

-- æ”¯ä»˜è®°å½•è¡¨
CREATE TABLE payments (
    id BIGSERIAL PRIMARY KEY,
    order_id BIGINT REFERENCES orders(id),
    order_no VARCHAR(50) UNIQUE NOT NULL,
    amount_cent BIGINT NOT NULL,
    payment_method VARCHAR(20), -- wechat/alipay/card
    payment_status VARCHAR(20) DEFAULT 'pending', -- pending/success/failed/refunded
    third_party_id VARCHAR(100), -- ç¬¬ä¸‰æ–¹äº¤æ˜“å·
    prepay_id VARCHAR(100),
    notify_data JSONB,
    paid_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);

-- ç´¢å¼•
CREATE INDEX idx_users_phone ON users(phone);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_user_status ON orders(user_id, status);
CREATE INDEX idx_payments_order_status ON payments(order_no, payment_status);
CREATE INDEX idx_organizations_parent ON organizations(parent_id);

-- æ’å…¥é»˜è®¤æ•°æ®
INSERT INTO roles (name, description, permissions) VALUES 
('admin', 'ç³»ç»Ÿç®¡ç†å‘˜', '["*"]'),
('operator', 'è¿è¥äººå‘˜', '["device.read", "device.write", "order.read", "station.read"]'),
('user', 'æ™®é€šç”¨æˆ·', '["order.read", "charging.start", "charging.stop"]');

INSERT INTO pricing_strategies (name, type, rules) VALUES 
('é»˜è®¤è®¡è´¹ç­–ç•¥', 'time', '{"price_per_hour": 200, "min_charge": 100}');
```

## ğŸ§ª æµ‹è¯•ç¤ºä¾‹

### å•å…ƒæµ‹è¯•
```go
// internal/auth/jwt_test.go
package auth

import (
    "testing"
    "time"
    "github.com/stretchr/testify/assert"
)

func TestJWTManager(t *testing.T) {
    manager := NewJWTManager("test-secret", time.Hour, time.Hour*24)
    
    // æµ‹è¯•ç”Ÿæˆtoken
    accessToken, refreshToken, err := manager.GenerateTokens(123, "testuser", 1)
    assert.NoError(t, err)
    assert.NotEmpty(t, accessToken)
    assert.NotEmpty(t, refreshToken)
    
    // æµ‹è¯•è§£ætoken
    claims, err := manager.ParseToken(accessToken)
    assert.NoError(t, err)
    assert.Equal(t, int64(123), claims.UserID)
    assert.Equal(t, "testuser", claims.Username)
    assert.Equal(t, int64(1), claims.OrgID)
}
```

### é›†æˆæµ‹è¯•
```go
// test/integration/charging_test.go
package integration

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestChargingFlow(t *testing.T) {
    // è®¾ç½®æµ‹è¯•ç¯å¢ƒ
    app := setupTestApp()
    
    // 1. ç”¨æˆ·æ³¨å†Œ
    registerReq := map[string]interface{}{
        "username": "testuser",
        "phone": "13800138000",
        "password": "password123",
    }
    
    body, _ := json.Marshal(registerReq)
    req := httptest.NewRequest("POST", "/api/v1/auth/register", bytes.NewBuffer(body))
    req.Header.Set("Content-Type", "application/json")
    
    w := httptest.NewRecorder()
    app.ServeHTTP(w, req)
    assert.Equal(t, 200, w.Code)
    
    // 2. ç”¨æˆ·ç™»å½•è·å–token
    loginReq := map[string]interface{}{
        "phone": "13800138000",
        "password": "password123",
    }
    
    body, _ = json.Marshal(loginReq)
    req = httptest.NewRequest("POST", "/api/v1/auth/login", bytes.NewBuffer(body))
    req.Header.Set("Content-Type", "application/json")
    
    w = httptest.NewRecorder()
    app.ServeHTTP(w, req)
    assert.Equal(t, 200, w.Code)
    
    var loginResp map[string]interface{}
    json.Unmarshal(w.Body.Bytes(), &loginResp)
    token := loginResp["access_token"].(string)
    
    // 3. å¯åŠ¨å……ç”µ
    chargingReq := map[string]interface{}{
        "device_phy_id": "test_device_001",
        "port_no": 1,
        "charging_mode": 1,
        "time_limit": 60,
        "estimated_amount": 1200,
    }
    
    body, _ = json.Marshal(chargingReq)
    req = httptest.NewRequest("POST", "/api/v1/charging/sessions", bytes.NewBuffer(body))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer "+token)
    
    w = httptest.NewRecorder()
    app.ServeHTTP(w, req)
    assert.Equal(t, 200, w.Code)
    
    var chargingResp map[string]interface{}
    json.Unmarshal(w.Body.Bytes(), &chargingResp)
    sessionID := chargingResp["session_id"].(string)
    
    // 4. æŸ¥è¯¢å……ç”µçŠ¶æ€
    req = httptest.NewRequest("GET", "/api/v1/charging/status/"+sessionID, nil)
    req.Header.Set("Authorization", "Bearer "+token)
    
    w = httptest.NewRecorder()
    app.ServeHTTP(w, req)
    assert.Equal(t, 200, w.Code)
    
    // 5. åœæ­¢å……ç”µ
    req = httptest.NewRequest("POST", "/api/v1/charging/stop/"+sessionID, nil)
    req.Header.Set("Authorization", "Bearer "+token)
    
    w = httptest.NewRecorder()
    app.ServeHTTP(w, req)
    assert.Equal(t, 200, w.Code)
}
```

---

è¿™äº›ä»£ç ç¤ºä¾‹æä¾›äº†æ ¸å¿ƒæŠ€æœ¯ç»„ä»¶çš„å®ç°æ¡†æ¶ï¼Œå¯ä»¥ä½œä¸ºå¼€å‘çš„èµ·ç‚¹ã€‚æ¯ä¸ªç»„ä»¶éƒ½éµå¾ªé¡¹ç›®ç°æœ‰çš„æ¶æ„é£æ ¼ï¼Œå¹¶è€ƒè™‘äº†ç”Ÿäº§ç¯å¢ƒçš„éœ€æ±‚ã€‚