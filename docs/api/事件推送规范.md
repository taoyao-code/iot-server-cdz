# 事件推送规范

> **版本**: v1.0.0  
> **更新日期**: 2025-01-03

---

## 概述

IOT Server通过Webhook方式主动推送设备事件到第三方平台。本文档详细说明事件推送的技术规范。

---

## 推送机制

### 架构

```
设备事件 → Redis队列 → Worker → Webhook → 第三方平台
           ↓
        去重器（Redis）
```

- **异步推送**: 不阻塞业务逻辑
- **可靠性保障**: 重试机制 + 死信队列
- **幂等性**: 基于event_id的去重
- **监控**: 完整的Prometheus指标

---

## 事件格式

### 标准事件结构

```json
{
  "event_id": "device.heartbeat-device-001-1704067200123456789",
  "event_type": "device.heartbeat",
  "device_phy_id": "device-001",
  "timestamp": 1704067200,
  "nonce": "a1b2c3d4",
  "data": {
    // 事件具体数据，根据event_type不同而不同
  }
}
```

**字段说明**:

- `event_id`: 事件唯一ID（用于去重）
- `event_type`: 事件类型（见下文）
- `device_phy_id`: 设备物理ID
- `timestamp`: 事件发生时间（Unix秒）
- `nonce`: 随机数（用于签名防重放）
- `data`: 事件数据（JSON对象）

---

## 事件类型详解

### 1. device.registered - 设备注册

```json
{
  "event_type": "device.registered",
  "data": {
    "iccid": "1234567890",
    "imei": "0987654321",
    "device_type": "charger",
    "firmware": "v1.0.0",
    "port_count": 4,
    "registered_at": 1704067200
  }
}
```

### 2. device.heartbeat - 设备心跳

```json
{
  "event_type": "device.heartbeat",
  "data": {
    "voltage": 220.5,
    "rssi": -75,
    "temp": 35.2,
    "ports": [
      {"port_no": 1, "state": "idle", "power": 0},
      {"port_no": 2, "state": "charging", "power": 1500.5}
    ]
  }
}
```

### 3. order.created - 订单创建

```json
{
  "event_type": "order.created",
  "data": {
    "order_no": "ORDER123456",
    "port_no": 1,
    "charge_mode": "time",
    "duration": 3600,
    "price_per_kwh": 1.5,
    "created_at": 1704067200
  }
}
```

### 4. order.completed - 订单完成

```json
{
  "event_type": "order.completed",
  "data": {
    "order_no": "ORDER123456",
    "port_no": 1,
    "duration": 3590,
    "total_kwh": 5.23,
    "peak_power": 2000,
    "avg_power": 1500,
    "total_amount": 7.85,
    "end_reason": "normal",
    "end_reason_msg": "充电完成",
    "completed_at": 1704070790
  }
}
```

### 5. charging.started - 充电开始

### 6. charging.ended - 充电结束

### 7. device.alarm - 设备告警

### 8. socket.state_changed - 插座状态变更

### 9. ota.progress_update - OTA进度更新

---

## 签名验证

### 签名算法

```
1. 构造canonical string:
   canonical = method\npath\ntimestamp\nnonce\nbody_sha256

2. 计算HMAC-SHA256签名:
   signature = HMAC-SHA256(secret, canonical)

3. Hex编码:
   final_signature = hex(signature)
```

### 示例（Python）

```python
import hmac
import hashlib
import json

def verify_signature(request, secret):
    # 1. 获取header
    signature = request.headers.get('X-Signature')
    timestamp = request.headers.get('X-Timestamp')
    nonce = request.headers.get('X-Nonce')
    
    # 2. 计算body的SHA256
    body = request.get_data()
    body_sha256 = hashlib.sha256(body).hexdigest()
    
    # 3. 构造canonical string
    method = request.method
    path = request.path
    canonical = f"{method}\n{path}\n{timestamp}\n{nonce}\n{body_sha256}"
    
    # 4. 计算HMAC-SHA256
    expected_sig = hmac.new(
        secret.encode(),
        canonical.encode(),
        hashlib.sha256
    ).hexdigest()
    
    # 5. 验证
    return hmac.compare_digest(signature, expected_sig)
```

### 验证步骤

1. 提取请求Header: `X-Signature`, `X-Timestamp`, `X-Nonce`
2. 读取请求Body，计算SHA256
3. 构造canonical string
4. 使用shared secret计算HMAC-SHA256
5. 比对签名

---

## 重试策略

### 重试条件

- 网络错误
- 5xx服务器错误
- 超时（10秒）

### 重试参数

- **最大重试次数**: 5次
- **退避策略**: 指数退避
  - 第1次重试: 延迟1秒
  - 第2次重试: 延迟2秒
  - 第3次重试: 延迟4秒
  - 第4次重试: 延迟8秒
  - 第5次重试: 延迟16秒

### 不重试情况

- 4xx客户端错误（除429外）
- 签名验证失败
- 达到最大重试次数

### 死信队列（DLQ）

重试失败的事件会被移入死信队列，包含：

- 原始事件数据
- 失败原因
- 失败时间

管理员可通过API查看和处理DLQ中的事件。

---

## 去重机制

### 去重原理

- 基于Redis的分布式去重
- Key: `thirdparty:dedup:{event_id}`
- TTL: 1小时（可配置）
- 原子操作：SetNX保证并发安全

### 幂等性保证

同一个`event_id`的事件：

- 首次推送：正常处理
- 重复推送：自动过滤，不会重复发送

第三方平台应基于`event_id`实现幂等性。

---

## 监控指标

### Prometheus指标

```
# 推送总数（按事件类型和结果）
thirdparty_push_total{event_type, result}

# 推送延迟
thirdparty_push_duration_seconds{event_type}

# 重试次数
thirdparty_push_retry_total{event_type}

# 队列长度
thirdparty_queue_size{queue_type}

# 去重命中次数
thirdparty_dedup_hit_total{event_type}
```

### 告警建议

- 推送成功率 < 99.5%
- 队列积压 > 10,000
- DLQ大小 > 1,000
- 重试率 > 5%

---

## 配置说明

### 服务端配置

```yaml
thirdparty:
  push:
    webhook_url: "https://your-domain.com/webhook/iot"
    secret: "your-secret-key"
    max_retries: 5
    worker_count: 3
    dedup_ttl: 1h
    enable_queue: true
    enable_dedup: true
```

### 配置建议

- `worker_count`: 2-5个，根据事件量调整
- `dedup_ttl`: 建议1-24小时
- 生产环境必须启用`enable_queue`和`enable_dedup`

---

## 最佳实践

### 第三方平台接收端

1. **实现幂等性**: 基于event_id去重
2. **快速响应**: 在3秒内返回2xx
3. **异步处理**: 接收后立即返回，异步处理
4. **验证签名**: 必须验证HMAC签名
5. **错误处理**: 4xx表示不可恢复错误，5xx表示临时错误

### 示例实现（FastAPI）

```python
from fastapi import FastAPI, Request, HTTPException
import hmac
import hashlib

app = FastAPI()

# 内存去重（生产环境使用Redis）
processed_events = set()

@app.post("/webhook/iot")
async def handle_iot_event(request: Request):
    # 1. 验证签名
    if not verify_signature(request, SECRET):
        raise HTTPException(status_code=401, detail="Invalid signature")
    
    # 2. 解析事件
    event = await request.json()
    event_id = event.get("event_id")
    
    # 3. 去重检查
    if event_id in processed_events:
        return {"status": "ok", "message": "duplicate event"}
    
    # 4. 标记已处理
    processed_events.add(event_id)
    
    # 5. 异步处理事件（放入队列）
    await process_event_async(event)
    
    # 6. 快速响应
    return {"status": "ok"}
```

---

## 故障排查

### 常见问题

**Q: 事件未收到**

- 检查webhook_url是否可访问
- 检查服务端日志
- 查看队列长度和DLQ

**Q: 收到重复事件**

- 检查第三方平台的去重逻辑
- 查看event_id是否正确处理

**Q: 签名验证失败**

- 确认secret配置一致
- 检查时间戳误差（建议允许±5分钟）
- 验证canonical string构造是否正确

---

## 性能指标

### 预期性能

- **吞吐量**: 1000事件/秒
- **推送成功率**: ≥99.5%
- **平均延迟**: <500ms
- **P99延迟**: <2s

### 容量规划

- 10,000设备: 3个worker
- 50,000设备: 5个worker
- 100,000设备: 10个worker + Redis集群

---

## 版本历史

- v1.0.0 (2025-01-03): 初始版本
  - 10种标准事件类型
  - Redis异步队列
  - 去重机制
  - HMAC签名
  - 重试+DLQ
