# IOT Server - æ¶æ„ä¼˜ç¼ºç‚¹åˆ†ææŠ¥å‘Š

> **åˆ†ææ—¥æœŸ**: 2025-10-05  
> **åˆ†æèŒƒå›´**: æ•´ä½“æ¶æ„ã€æ ¸å¿ƒç»„ä»¶ã€æŠ€æœ¯é€‰å‹  
> **åˆ†ææ–¹æ³•**: ä»£ç å®¡æŸ¥ + æœ€ä½³å®è·µå¯¹æ¯”

---

## ä¸€ã€æ•´ä½“è¯„ä¼°

### 1.1 æ¶æ„æˆç†Ÿåº¦

| ç»´åº¦ | è¯„åˆ† | è¯´æ˜ |
|-----|------|------|
| **ä»£ç ç»“æ„** | â­â­â­â­ | æ¸…æ™°çš„åˆ†å±‚ï¼ŒèŒè´£æ˜ç¡® |
| **å¯æ‰©å±•æ€§** | â­â­ | å—é™äºå†…å­˜çŠ¶æ€ï¼Œéš¾ä»¥æ°´å¹³æ‰©å±• |
| **å¯æµ‹è¯•æ€§** | â­â­ | é—­åŒ…ä¾èµ–æ³¨å…¥ï¼Œæµ‹è¯•å›°éš¾ |
| **å¯è§‚æµ‹æ€§** | â­â­â­ | æœ‰æŒ‡æ ‡å’Œæ—¥å¿—ï¼Œç¼ºå°‘è¿½è¸ª |
| **æ€§èƒ½ä¼˜åŒ–** | â­â­â­ | åŸºæœ¬ä¼˜åŒ–åˆ°ä½ï¼Œä»æœ‰æå‡ç©ºé—´ |
| **å®‰å…¨æ€§** | â­â­ | ç¼ºå°‘è®¤è¯ã€é™æµç­‰å…³é”®æœºåˆ¶ |

**ç»¼åˆè¯„åˆ†**: â­â­â­ (3/5) - **å¯ç”¨äºç”Ÿäº§ï¼Œä½†éœ€æ”¹è¿›**

---

## äºŒã€æ¶æ„ä¼˜ç‚¹ âœ…

### 2.1 åˆ†å±‚è®¾è®¡æ¸…æ™°

**è¡¨ç°**:

```
åº”ç”¨å±‚(cmd) â†’ ä¸šåŠ¡å±‚(app) â†’ æœåŠ¡å±‚(gateway/session/outbound) 
â†’ åè®®å±‚(protocol) â†’ æ•°æ®å±‚(storage) â†’ åŸºç¡€è®¾æ–½å±‚(tcp/http)
```

**ä¼˜åŠ¿**:

- âœ… èŒè´£è¾¹ç•Œæ¸…æ™°
- âœ… æ˜“äºç†è§£å’Œç»´æŠ¤
- âœ… å¯ä»¥ç‹¬ç«‹æµ‹è¯•å„å±‚
- âœ… ç¬¦åˆDDDæ€æƒ³

**ä»£ç ç¤ºä¾‹**:

```go
// æ¸…æ™°çš„èŒè´£åˆ†ç¦»
cmd/server/main.go           // å…¥å£ï¼šåŠ è½½é…ç½®
internal/app/bootstrap/      // å¯åŠ¨ï¼šä¾èµ–æ³¨å…¥
internal/gateway/            // æœåŠ¡ï¼šè¿æ¥å¤„ç†
internal/protocol/           // åè®®ï¼šè§£æç¼–ç 
internal/storage/            // æ•°æ®ï¼šæŒä¹…åŒ–
```

---

### 2.2 åè®®é€‚é…å™¨æ¨¡å¼ ğŸ¯

**è®¾è®¡**:

```go
type Adapter interface {
    Sniff(prefix []byte) bool
    ProcessBytes(data []byte) error
}

// AP3000ã€BKVã€GN éƒ½å®ç°æ­¤æ¥å£
```

**ä¼˜åŠ¿**:

- âœ… **æ’ä»¶åŒ–æ‰©å±•**ï¼šæ–°å¢åè®®æ— éœ€æ”¹åŠ¨æ ¸å¿ƒä»£ç 
- âœ… **åè®®éš”ç¦»**ï¼šå„åè®®ç‹¬ç«‹æ¼”è¿›
- âœ… **è¿è¡Œæ—¶è¯†åˆ«**ï¼šé€šè¿‡ `Sniff()` è‡ªåŠ¨è¯†åˆ«åè®®
- âœ… **çƒ­æ’æ‹”**ï¼šé…ç½®æ§åˆ¶åè®®å¯ç”¨/ç¦ç”¨

**ä»£ç è·¯å¾„**:

```
internal/protocol/
â”œâ”€â”€ adapter/       # åè®®æ¥å£å®šä¹‰
â”œâ”€â”€ ap3000/        # AP3000åè®®å®ç°
â”œâ”€â”€ bkv/           # BKVåè®®å®ç°
â””â”€â”€ gn/            # GNåè®®å®ç°
```

**æ‰©å±•ç¤ºä¾‹**:

```go
// æ–°å¢åè®®åªéœ€3æ­¥ï¼š
// 1. å®ç°Adapteræ¥å£
type NewProtocol struct {}
func (p *NewProtocol) Sniff([]byte) bool { ... }
func (p *NewProtocol) ProcessBytes([]byte) error { ... }

// 2. æ³¨å†Œåˆ°Gateway
gateway.RegisterProtocol("new", newAdapter)

// 3. é…ç½®å¯ç”¨
protocols.enable_new = true
```

---

### 2.3 é…ç½®é©±åŠ¨æ¶æ„ âš™ï¸

**ç‰¹æ€§**:

```yaml
# çµæ´»çš„é…ç½®ç®¡ç†
tcp:
  addr: ":8899"
  readTimeout: 300s

protocols:
  enableAP3000: true
  enableBKV: true

database:
  dsn: postgres://...
  maxOpenConns: 20
```

**ä¼˜åŠ¿**:

- âœ… ç¯å¢ƒå˜é‡è¦†ç›–ï¼ˆ`IOT_DB_HOST`ï¼‰
- âœ… å¤šæ ¼å¼æ”¯æŒï¼ˆYAML/TOML/JSONï¼‰
- âœ… é»˜è®¤å€¼åˆç†
- âœ… Viperå¼ºå¤§çš„é…ç½®ç®¡ç†

**å®ç°ä»£ç **: `internal/config/config.go`

---

### 2.4 ç›‘æ§ä¸å¯è§‚æµ‹æ€§ ğŸ“Š

**Prometheus æŒ‡æ ‡**:

```go
type AppMetrics struct {
    TCPAccepted       Counter   // TCPè¿æ¥æ•°
    ProtocolMessages  CounterVec // åè®®æ¶ˆæ¯æ•°(by protocol)
    HeartbeatTotal    Counter   // å¿ƒè·³æ€»æ•°
    OnlineGauge       Gauge     // åœ¨çº¿è®¾å¤‡æ•°
    OutboundSent      Counter   // ä¸‹å‘æ¶ˆæ¯æ•°
    OutboundFailed    Counter   // ä¸‹å‘å¤±è´¥æ•°
}
```

**ä¼˜åŠ¿**:

- âœ… å…³é”®æŒ‡æ ‡è¦†ç›–å®Œæ•´
- âœ… Prometheusæ ‡å‡†æ ¼å¼
- âœ… æ”¯æŒå¤šç»´åº¦æ ‡ç­¾
- âœ… å®æ—¶ç›‘æ§å°±ç»ª

**ä»£ç è·¯å¾„**: `internal/metrics/metrics.go`

---

### 2.5 ä¼šè¯ç®¡ç†è®¾è®¡ ğŸ“¡

**ç‰¹æ€§**:

```go
type Manager struct {
    lastSeen       map[string]time.Time  // å¿ƒè·³æ—¶é—´
    conns          map[string]interface{} // è¿æ¥æ˜ å°„
    lastTCPDown    map[string]time.Time  // TCPæ–­å¼€æ—¶é—´
    lastAckTimeout map[string]time.Time  // ACKè¶…æ—¶æ—¶é—´
}

// å¤šä¿¡å·åŠ æƒåˆ¤å®š
func (m *Manager) IsOnlineWeighted(phyID string, now time.Time, policy WeightedPolicy) bool
```

**ä¼˜åŠ¿**:

- âœ… å¤šä¿¡å·ç¦»çº¿åˆ¤å®šï¼ˆå¿ƒè·³+TCP+ACKï¼‰
- âœ… åŠ æƒè¯„åˆ†æœºåˆ¶
- âœ… æ”¯æŒè®¾å¤‡å¿«é€Ÿé‡è¿åˆ¤å®š
- âœ… çº¿ç¨‹å®‰å…¨

**ä»£ç è·¯å¾„**: `internal/session/manager.go`

---

### 2.6 ä¼˜é›…å…³é—­æœºåˆ¶ ğŸ›‘

**å®ç°**:

```go
func Run(cfg *Config, log *zap.Logger) error {
    sigCh := make(chan os.Signal, 1)
    signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
    <-sigCh

    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    _ = httpSrv.Shutdown(ctx)  // å…ˆå…³HTTP
    _ = tcpSrv.Shutdown(ctx)   // å†å…³TCP
    // æ•°æ®åº“è¿æ¥é€šè¿‡deferå…³é—­
}
```

**ä¼˜åŠ¿**:

- âœ… ä¿¡å·å¤„ç†ï¼ˆSIGINT/SIGTERMï¼‰
- âœ… 10ç§’è¶…æ—¶ä¿æŠ¤
- âœ… æœ‰åºå…³é—­ï¼ˆHTTPâ†’TCPâ†’DBï¼‰
- âœ… WaitGroupç­‰å¾…æ‰€æœ‰è¿æ¥é€€å‡º

---

### 2.7 æ•°æ®åº“è¿ç§»æœºåˆ¶ ğŸ—ƒï¸

**ç‰¹æ€§**:

```
db/migrations/
â”œâ”€â”€ 0001_init_up.sql
â”œâ”€â”€ 0001_init_down.sql
â”œâ”€â”€ 0002_outbox_up.sql
â”œâ”€â”€ 0003_outbound_msgid_up.sql
â””â”€â”€ 0004_gn_protocol_up.sql
```

**ä¼˜åŠ¿**:

- âœ… ç‰ˆæœ¬åŒ–ç®¡ç†
- âœ… æ”¯æŒå›æ»šï¼ˆup/downï¼‰
- âœ… è‡ªåŠ¨è¿ç§»å¯é…ç½®
- âœ… ä½¿ç”¨ golang-migrate æ ‡å‡†å·¥å…·

**ä»£ç è·¯å¾„**: `internal/migrate/runner.go`

---

### 2.8 è¿æ¥ä¸Šä¸‹æ–‡ç®¡ç† ğŸ”Œ

**è®¾è®¡**:

```go
type ConnContext struct {
    conn     net.Conn
    done     chan struct{}
    protocol string
}

func (cc *ConnContext) Write(data []byte) error
func (cc *ConnContext) Done() <-chan struct{}
func (cc *ConnContext) Protocol() string
```

**ä¼˜åŠ¿**:

- âœ… å°è£…è¿æ¥ç”Ÿå‘½å‘¨æœŸ
- âœ… æä¾›ä¼˜é›…å…³é—­é€šçŸ¥
- âœ… åè®®æ ‡è¯†ç»‘å®š
- âœ… ç‹¬ç«‹çš„è¯»å†™ç¼“å†²åŒº

**ä»£ç è·¯å¾„**: `internal/tcpserver/conn.go`

---

### 2.9 ä¸‹è¡Œé˜Ÿåˆ—é‡è¯•æœºåˆ¶ ğŸ”„

**ç‰¹æ€§**:

```sql
CREATE TABLE outbound_queue (
    id SERIAL PRIMARY KEY,
    status INT,         -- 0=å¾…å‘é€, 1=å·²å‘é€, 2=å·²å®Œæˆ, 3=å¤±è´¥
    retry_count INT,    -- é‡è¯•æ¬¡æ•°
    not_before TIMESTAMP, -- å»¶è¿Ÿå‘é€æ—¶é—´
    timeout_sec INT,    -- è¶…æ—¶ç§’æ•°
    ...
);
```

**ä¼˜åŠ¿**:

- âœ… æŒä¹…åŒ–é˜Ÿåˆ—ï¼ˆæ–­ç”µä¸ä¸¢å¤±ï¼‰
- âœ… æŒ‡æ•°é€€é¿é‡è¯•
- âœ… ACKç¡®è®¤æœºåˆ¶
- âœ… æ­»ä¿¡é˜Ÿåˆ—å¤„ç†
- âœ… èŠ‚æµæ§åˆ¶

**ä»£ç è·¯å¾„**: `internal/outbound/worker.go`

---

## ä¸‰ã€æ¶æ„ç¼ºç‚¹ âš ï¸

### 3.1 â›” ä¼šè¯çŠ¶æ€æ— æ³•æ°´å¹³æ‰©å±• (é«˜å±)

**é—®é¢˜æè¿°**:

```go
// internal/session/manager.go
type Manager struct {
    mu       sync.RWMutex
    lastSeen map[string]time.Time    // âŒ å†…å­˜å­˜å‚¨
    conns    map[string]interface{}  // âŒ è¿æ¥å¯¹è±¡åœ¨å†…å­˜
}
```

**å½±å“**:

- âŒ **æ— æ³•å¤šå®ä¾‹éƒ¨ç½²**ï¼šè®¾å¤‡è¿æ¥åˆ°Server1ï¼Œå‘½ä»¤åœ¨Server2æ— æ³•ä¸‹å‘
- âŒ **å•ç‚¹æ•…éšœ**ï¼šServeré‡å¯æ‰€æœ‰ä¼šè¯ä¸¢å¤±
- âŒ **å†…å­˜å—é™**ï¼š10ä¸‡è®¾å¤‡çº¦éœ€1GBå†…å­˜
- âŒ **æ— æ³•åŠ¨æ€æ‰©å®¹**

**è¡¨ç°**:

```
è®¾å¤‡è¿æ¥åˆ°Server1
    â†“
é‡å¯/æ•…éšœ
    â†“
è®¾å¤‡é‡è¿åˆ°Server2ï¼ˆè´Ÿè½½å‡è¡¡ï¼‰
    â†“
Server2æ— æ³•è¯†åˆ«è®¾å¤‡å†å²ä¼šè¯
    â†“
ä¸šåŠ¡ä¸­æ–­
```

**æ”¹è¿›æ–¹æ¡ˆ**:

```go
// æ–¹æ¡ˆ1: Rediså­˜å‚¨ä¼šè¯
type RedisSessionStore struct {
    client *redis.Client
}

func (s *RedisSessionStore) Bind(phyID string, serverAddr string) {
    s.client.Set(ctx, "session:"+phyID, serverAddr, 10*time.Minute)
}

func (s *RedisSessionStore) GetServer(phyID string) (string, error) {
    return s.client.Get(ctx, "session:"+phyID).Result()
}

// æ–¹æ¡ˆ2: ä¸€è‡´æ€§å“ˆå¸Œè·¯ç”±
func RouteDevice(phyID string, servers []string) string {
    hash := fnv.New32a()
    hash.Write([]byte(phyID))
    idx := hash.Sum32() % uint32(len(servers))
    return servers[idx]
}
```

**å·¥ä½œé‡**: 3-5å¤©  
**ä¼˜å…ˆçº§**: ğŸ”´ é«˜

---

### 3.2 â›” Outboundé˜Ÿåˆ—æ€§èƒ½ç“¶é¢ˆ (ä¸­å±)

**é—®é¢˜æè¿°**:

```go
// internal/outbound/worker.go
func (w *Worker) tick(ctx context.Context) {
    // âŒ ä½¿ç”¨PostgreSQLä½œä¸ºæ¶ˆæ¯é˜Ÿåˆ—
    rows, err := w.DB.Query(ctx, `SELECT id, phy_id, cmd, payload 
        FROM outbound_queue WHERE status=0 ...`)
}
```

**å½±å“**:

- âŒ **ååé‡ä½**ï¼šPostgreSQLä¸é€‚åˆé«˜é¢‘è½®è¯¢
- âŒ **å»¶è¿Ÿé«˜**ï¼š1ç§’è½®è¯¢é—´éš”ï¼Œæœ€åå»¶è¿Ÿ1ç§’
- âŒ **æ•°æ®åº“å‹åŠ›**ï¼šæ¯ç§’Næ¬¡SELECTä¼šå½±å“ä¸»ä¸šåŠ¡
- âŒ **æ— æ³•å³æ—¶æ¨é€**

**æ€§èƒ½å¯¹æ¯”**:

| æ–¹æ¡ˆ | ååé‡(msg/s) | å»¶è¿Ÿ(ms) | è¯´æ˜ |
|-----|--------------|----------|------|
| **PostgreSQL (å½“å‰)** | ~1,000 | 500-1000 | è½®è¯¢é—´éš” |
| **Redis List** | ~10,000 | 10-50 | BLPOPé˜»å¡ |
| **RabbitMQ** | ~50,000 | 5-20 | ä¸“ä¸šæ¶ˆæ¯é˜Ÿåˆ— |
| **Kafka** | ~100,000 | 5-10 | é«˜åååœºæ™¯ |

**æ”¹è¿›æ–¹æ¡ˆ**:

```go
// æ–¹æ¡ˆ1: Redis List + BLPOP
func (w *Worker) consumeFromRedis() {
    for {
        result := w.redis.BLPop(ctx, 0, "outbound_queue").Val()
        // å¤„ç†æ¶ˆæ¯
    }
}

// æ–¹æ¡ˆ2: RabbitMQ
func (w *Worker) consumeFromRabbitMQ() {
    msgs, _ := w.channel.Consume("outbound", "", false, false, false, false, nil)
    for msg := range msgs {
        // å¤„ç†æ¶ˆæ¯
        msg.Ack(false)
    }
}
```

**å·¥ä½œé‡**: 5-7å¤©  
**ä¼˜å…ˆçº§**: ğŸŸ¡ ä¸­

---

### 3.3 â›” å‚æ•°å­˜å‚¨ä¸´æ—¶æ–¹æ¡ˆ (é«˜å±)

**é—®é¢˜æè¿°**:

```go
// internal/protocol/bkv/wire.go
type repoAdapter struct {
    *pgstorage.Repository
    // âŒ ç®€å•çš„å†…å­˜å­˜å‚¨ç”¨äºå‚æ•°æ ¡éªŒï¼ˆç”Ÿäº§ç¯å¢ƒåº”è¯¥ä½¿ç”¨æ•°æ®åº“ï¼‰
    paramStore map[string]paramEntry
}

// TODO: Replace with proper database-backed parameter storage. See issue #XXX.
```

**å½±å“**:

- âŒ **æ•°æ®ä¸¢å¤±**ï¼šæœåŠ¡é‡å¯åå‚æ•°å†™å…¥è®°å½•ä¸¢å¤±
- âŒ **æ— æ³•å®¡è®¡**ï¼šæ²¡æœ‰æŒä¹…åŒ–è®°å½•
- âŒ **å¹¶å‘å†²çª**ï¼šå¤šå®ä¾‹éƒ¨ç½²æ—¶æ— æ³•å…±äº«çŠ¶æ€
- âŒ **å†…å­˜æ³„æ¼é£é™©**ï¼šmapæ— æ¸…ç†æœºåˆ¶

**æ”¹è¿›æ–¹æ¡ˆ**:

```sql
-- åˆ›å»ºå‚æ•°è¡¨
CREATE TABLE device_params (
    id SERIAL PRIMARY KEY,
    device_id BIGINT NOT NULL,
    param_id INT NOT NULL,
    param_value BYTEA,
    msg_id INT,
    status INT, -- 0=å¾…ç¡®è®¤, 1=å·²ç¡®è®¤, 2=å¤±è´¥
    created_at TIMESTAMP DEFAULT NOW(),
    confirmed_at TIMESTAMP,
    UNIQUE(device_id, param_id)
);

CREATE INDEX idx_device_params_pending ON device_params(device_id, param_id) WHERE status=0;
```

```go
// å®ç°æŒä¹…åŒ–
func (r *Repository) StoreParamWrite(ctx context.Context, deviceID int64, paramID int, value []byte, msgID int) error {
    const q = `INSERT INTO device_params (device_id, param_id, param_value, msg_id, status)
               VALUES ($1,$2,$3,$4,0)
               ON CONFLICT (device_id, param_id) DO UPDATE 
               SET param_value=$3, msg_id=$4, status=0, created_at=NOW()`
    _, err := r.Pool.Exec(ctx, q, deviceID, paramID, value, msgID)
    return err
}
```

**å·¥ä½œé‡**: 1å¤©  
**ä¼˜å…ˆçº§**: ğŸ”´ é«˜

---

### 3.4 ğŸš¨ å¯åŠ¨é¡ºåºç¼ºé™·

**é—®é¢˜æè¿°**:

```go
// internal/app/bootstrap/app.go
func Run(cfg *Config, log *zap.Logger) error {
    // 1. åˆ›å»ºHandlerï¼ˆä½†æ­¤æ—¶repo=nilï¼‰
    var handlerSet *ap3000.Handlers
    var bkvHandlers *bkv.Handlers
    tcpSrv.SetConnHandler(gateway.NewConnHandler(..., 
        func() *ap3000.Handlers { return handlerSet },  // âŒ é—­åŒ…æ•è·nil
        func() *bkv.Handlers { return bkvHandlers }))   // âŒ é—­åŒ…æ•è·nil
    
    // 2. å¯åŠ¨TCPï¼ˆå¼€å§‹æ¥å—è¿æ¥ï¼‰
    if err := tcpSrv.Start(); err != nil {
        log.Fatal("tcp server start error", zap.Error(err))
    }
    
    // 3. è¿æ¥æ•°æ®åº“ï¼ˆæ­¤æ—¶TCPå·²ç»åœ¨æ¥å—è¿æ¥ï¼‰
    dbpool, err := app.ConnectDBAndMigrate(...)
    if err != nil {
        log.Error("db connect error", zap.Error(err))  // âŒ åªæ˜¯è­¦å‘Šï¼Œç»§ç»­è¿è¡Œ
    } else {
        // 4. åˆå§‹åŒ–Handlerï¼ˆè®¾å¤‡å¯èƒ½å·²ç»è¿æ¥å¹¶å‘é€æ•°æ®ï¼‰
        handlerSet = &ap3000.Handlers{Repo: repo, ...}
        bkvHandlers = bkv.NewHandlers(repo, bkvReason)
    }
}
```

**å½±å“**:

- âŒ **ç©ºçª—æœŸ**ï¼šTCPå¯åŠ¨åˆ°DBè¿æ¥ä¹‹é—´ï¼Œè®¾å¤‡æ¶ˆæ¯æ— æ³•å¤„ç†
- âŒ **æ•°æ®ä¸¢å¤±**ï¼šæ—©æœŸè¿æ¥çš„è®¾å¤‡æ¶ˆæ¯è¢«å¿½ç•¥
- âŒ **å¯åŠ¨å¤±è´¥å®¹å¿åº¦ä½**ï¼šDBå¤±è´¥åªæ˜¯è­¦å‘Šï¼ŒæœåŠ¡ç»§ç»­ä½†æ— æ³•å·¥ä½œ

**æ—¶åºå›¾**:

```
0s:  TCP Server Start âœ…
     â†“ (è®¾å¤‡å¼€å§‹è¿æ¥)
1s:  è®¾å¤‡1å‘é€å¿ƒè·³ â†’ handlerSet=nil â†’ æ¶ˆæ¯ä¸¢å¤± âŒ
2s:  è®¾å¤‡2å‘é€æ•°æ® â†’ handlerSet=nil â†’ æ¶ˆæ¯ä¸¢å¤± âŒ
3s:  DB Connected âœ…
4s:  Handlers Initialized âœ…
5s:  è®¾å¤‡3å‘é€æ•°æ® â†’ æ­£å¸¸å¤„ç† âœ…
```

**æ”¹è¿›æ–¹æ¡ˆ**:

```go
func Run(cfg *Config, log *zap.Logger) error {
    // 1. å…ˆè¿æ¥æ•°æ®åº“
    dbpool, err := app.ConnectDBAndMigrate(...)
    if err != nil {
        return fmt.Errorf("db init failed: %w", err)  // âœ… å¤±è´¥ç›´æ¥è¿”å›
    }
    defer dbpool.Close()
    
    // 2. åˆå§‹åŒ–Handler
    repo := &pgstorage.Repository{Pool: dbpool}
    handlerSet := &ap3000.Handlers{Repo: repo, ...}
    bkvHandlers := bkv.NewHandlers(repo, bkvReason)
    
    // 3. é…ç½®Gatewayï¼ˆHandlerå·²å°±ç»ªï¼‰
    tcpSrv.SetConnHandler(gateway.NewConnHandler(..., 
        func() *ap3000.Handlers { return handlerSet },  // âœ… énil
        func() *bkv.Handlers { return bkvHandlers }))
    
    // 4. æœ€åå¯åŠ¨TCPï¼ˆæ­¤æ—¶ä¸€åˆ‡å°±ç»ªï¼‰
    if err := tcpSrv.Start(); err != nil {
        return fmt.Errorf("tcp start failed: %w", err)
    }
    
    ready.SetTCPReady(true)
    ready.SetDBReady(true)
}
```

**å·¥ä½œé‡**: 0.5å¤©  
**ä¼˜å…ˆçº§**: ğŸ”´ é«˜

---

### 3.5 ğŸ”§ ä¾èµ–æ³¨å…¥æ–¹å¼ä¸åˆ©äºæµ‹è¯•

**é—®é¢˜æè¿°**:

```go
// internal/gateway/conn_handler.go
func NewConnHandler(
    protocols cfgpkg.ProtocolsConfig,
    sess *session.Manager,           // âŒ å…·ä½“ç±»å‹ï¼Œæ— æ³•mock
    policy session.WeightedPolicy,
    appm *metrics.AppMetrics,        // âŒ å…·ä½“ç±»å‹ï¼Œæ— æ³•mock
    getAP3000Handlers func() *ap3000.Handlers,  // âŒ å‡½æ•°é—­åŒ…ï¼Œéš¾ä»¥æµ‹è¯•
    getBKVHandlers func() *bkv.Handlers,
) func(*tcpserver.ConnContext)
```

**å½±å“**:

- âŒ **å•å…ƒæµ‹è¯•å›°éš¾**ï¼šæ— æ³•mockä¾èµ–
- âŒ **é›†æˆæµ‹è¯•å¤æ‚**ï¼šéœ€è¦å¯åŠ¨å®Œæ•´ç¯å¢ƒ
- âŒ **æ— æ³•éš”ç¦»æµ‹è¯•**ï¼šå¿…é¡»ä¾èµ–çœŸå®ç»„ä»¶

**å½“å‰æµ‹è¯•å›°å¢ƒ**:

```go
// âŒ æ— æ³•å†™è¿™æ ·çš„æµ‹è¯•
func TestConnHandler(t *testing.T) {
    mockSession := &MockSession{}      // æ— æ³•ä¼ å…¥ï¼Œè¦æ±‚*session.Manager
    mockMetrics := &MockMetrics{}      // æ— æ³•ä¼ å…¥ï¼Œè¦æ±‚*metrics.AppMetrics
    handler := gateway.NewConnHandler(...)  // å¿…é¡»ä¼ å…¥çœŸå®å¯¹è±¡
}
```

**æ”¹è¿›æ–¹æ¡ˆ**:

```go
// å®šä¹‰æ¥å£
type SessionManager interface {
    Bind(phyID string, conn interface{})
    GetConn(phyID string) (interface{}, bool)
    OnHeartbeat(phyID string, t time.Time)
}

type MetricsCollector interface {
    TCPAccepted() prometheus.Counter
    HeartbeatTotal() prometheus.Counter
    OnlineGauge() prometheus.Gauge
}

type HandlerFactory interface {
    AP3000Handler() *ap3000.Handlers
    BKVHandler() *bkv.Handlers
}

// ä½¿ç”¨æ¥å£
func NewConnHandler(
    protocols cfgpkg.ProtocolsConfig,
    sess SessionManager,          // âœ… æ¥å£ï¼Œå¯mock
    metrics MetricsCollector,     // âœ… æ¥å£ï¼Œå¯mock
    factory HandlerFactory,       // âœ… æ¥å£ï¼Œå¯mock
) func(*tcpserver.ConnContext)

// æµ‹è¯•æ—¶
type MockSession struct {}
func (m *MockSession) Bind(phyID string, conn interface{}) {}
func (m *MockSession) GetConn(phyID string) (interface{}, bool) { return nil, false }

func TestConnHandler(t *testing.T) {
    handler := gateway.NewConnHandler(cfg, &MockSession{}, &MockMetrics{}, &MockFactory{})
    // âœ… å®Œå…¨éš”ç¦»æµ‹è¯•
}
```

**å·¥ä½œé‡**: 3-5å¤©ï¼ˆé‡æ„æ‰€æœ‰ä¾èµ–ï¼‰  
**ä¼˜å…ˆçº§**: ğŸŸ¡ ä¸­

---

### 3.6 ğŸš¦ ç¼ºå°‘é™æµå’Œæ–­è·¯å™¨

**é—®é¢˜æè¿°**:

```go
// internal/tcpserver/server.go
func (s *Server) Start() error {
    for {
        conn, err := s.ln.Accept()  // âŒ æ— è¿æ¥æ•°é™åˆ¶
        if err != nil {
            time.Sleep(50 * time.Millisecond)
            continue
        }
        // âŒ æ— é™åˆ¶æ¥å—è¿æ¥
        go s.handleConn(conn)
    }
}
```

**å½±å“**:

- âŒ **æ‹’ç»æœåŠ¡æ”»å‡»**ï¼šæ¶æ„è¿æ¥è€—å°½èµ„æº
- âŒ **é›ªå´©æ•ˆåº”**ï¼šæ•…éšœè®¾å¤‡å¤§é‡é‡è¿
- âŒ **èµ„æºè€—å°½**ï¼šgoroutineæ— é™å¢é•¿

**æ”¹è¿›æ–¹æ¡ˆ**:

```go
// 1. è¿æ¥æ•°é™æµ
type Limiter struct {
    sem chan struct{}
}

func NewLimiter(max int) *Limiter {
    return &Limiter{sem: make(chan struct{}, max)}
}

func (l *Limiter) Acquire() bool {
    select {
    case l.sem <- struct{}{}:
        return true
    default:
        return false  // è¾¾åˆ°ä¸Šé™
    }
}

func (l *Limiter) Release() {
    <-l.sem
}

// 2. ä½¿ç”¨é™æµå™¨
func (s *Server) Start() error {
    limiter := NewLimiter(s.cfg.MaxConnections)
    for {
        conn, err := s.ln.Accept()
        if err != nil {
            continue
        }
        
        if !limiter.Acquire() {
            conn.Close()  // âœ… æ‹’ç»è¶…é™è¿æ¥
            metrics.ConnectionsRejected.Inc()
            continue
        }
        
        go func() {
            defer limiter.Release()
            s.handleConn(conn)
        }()
    }
}

// 3. æ–­è·¯å™¨ï¼ˆé˜²æ­¢ä¸‹æ¸¸æœåŠ¡æ•…éšœï¼‰
type CircuitBreaker struct {
    maxFailures int
    timeout     time.Duration
    failures    int
    lastFail    time.Time
    state       string // "closed", "open", "half-open"
}

func (cb *CircuitBreaker) Call(fn func() error) error {
    if cb.state == "open" {
        if time.Since(cb.lastFail) > cb.timeout {
            cb.state = "half-open"  // å°è¯•æ¢å¤
        } else {
            return errors.New("circuit breaker open")
        }
    }
    
    err := fn()
    if err != nil {
        cb.failures++
        cb.lastFail = time.Now()
        if cb.failures >= cb.maxFailures {
            cb.state = "open"
        }
        return err
    }
    
    cb.failures = 0
    cb.state = "closed"
    return nil
}
```

**å·¥ä½œé‡**: 2-3å¤©  
**ä¼˜å…ˆçº§**: ğŸŸ¡ ä¸­

---

### 3.7 ğŸ” ç¼ºå°‘åˆ†å¸ƒå¼è¿½è¸ª

**é—®é¢˜æè¿°**:

```go
// å½“å‰æ—¥å¿—ï¼šæ— æ³•å…³è”åŒä¸€è¯·æ±‚çš„å¤šæ¡æ—¥å¿—
logger.Info("device connected", zap.String("phy_id", phyID))
// ... å¤„ç†é€»è¾‘
logger.Info("data persisted", zap.String("phy_id", phyID))
// ... æ¨é€ç¬¬ä¸‰æ–¹
logger.Info("webhook sent", zap.String("phy_id", phyID))

// âŒ æ— æ³•è¿½è¸ªå®Œæ•´é“¾è·¯
```

**å½±å“**:

- âŒ **é—®é¢˜å®šä½å›°éš¾**ï¼šæ— æ³•è¿½è¸ªè¯·æ±‚å®Œæ•´è·¯å¾„
- âŒ **æ€§èƒ½åˆ†æå—é™**ï¼šæ— æ³•è¯†åˆ«æ…¢è¯·æ±‚ç“¶é¢ˆ
- âŒ **å¾®æœåŠ¡åä½œå›°éš¾**ï¼šæœªæ¥æ‹†åˆ†æœåŠ¡åæ— æ³•è¿½è¸ª

**æ”¹è¿›æ–¹æ¡ˆ**:

```go
// æ–¹æ¡ˆ1: OpenTelemetry
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

func HandleMessage(ctx context.Context, frame *Frame) error {
    // åˆ›å»ºSpan
    ctx, span := otel.Tracer("iot-server").Start(ctx, "HandleMessage")
    defer span.End()
    
    span.SetAttributes(
        attribute.String("phy_id", frame.PhyID),
        attribute.Int("cmd", frame.Cmd),
    )
    
    // æŒä¹…åŒ–ï¼ˆè‡ªåŠ¨ä¼ æ’­ctxï¼‰
    if err := repo.Save(ctx, frame); err != nil {
        span.RecordError(err)
        return err
    }
    
    // æ¨é€ç¬¬ä¸‰æ–¹ï¼ˆè‡ªåŠ¨ä¼ æ’­ctxï¼‰
    return pusher.Send(ctx, frame)
}

// æ—¥å¿—è¾“å‡ºï¼š
// [trace_id=abc123] device connected phy_id=DEV001
// [trace_id=abc123] data persisted phy_id=DEV001
// [trace_id=abc123] webhook sent phy_id=DEV001
// âœ… é€šè¿‡trace_idå…³è”æ•´ä¸ªæµç¨‹
```

**å·¥ä½œé‡**: 3-5å¤©  
**ä¼˜å…ˆçº§**: ğŸŸ¢ ä½ï¼ˆä½†æ¨èï¼‰

---

### 3.8 ğŸ” ç¼ºå°‘è®¤è¯å’ŒAPIç½‘å…³

**é—®é¢˜æè¿°**:

```go
// internal/api/routes.go
func RegisterReadOnlyRoutes(r *gin.Engine, repo *pg.Repository, ...) {
    api := r.Group("/api")
    {
        api.GET("/devices", ...)      // âŒ æ— è®¤è¯
        api.GET("/devices/:id", ...)  // âŒ æ— è®¤è¯
        api.GET("/orders", ...)       // âŒ æ— è®¤è¯
    }
}
```

**å½±å“**:

- âŒ **æ•°æ®æ³„éœ²é£é™©**ï¼šä»»ä½•äººå¯æŸ¥è¯¢è®¾å¤‡ä¿¡æ¯
- âŒ **æ— æƒé™æ§åˆ¶**ï¼šæ— æ³•åŒºåˆ†ä¸åŒè§’è‰²
- âŒ **æ— å®¡è®¡æ—¥å¿—**ï¼šæ— æ³•è¿½è¸ªAPIè°ƒç”¨

**æ”¹è¿›æ–¹æ¡ˆ**:

```go
// 1. API Keyè®¤è¯ä¸­é—´ä»¶
func APIKeyAuth(keys []string) gin.HandlerFunc {
    return func(c *gin.Context) {
        apiKey := c.GetHeader("X-API-Key")
        if apiKey == "" {
            c.AbortWithStatusJSON(401, gin.H{"error": "missing api key"})
            return
        }
        
        valid := false
        for _, k := range keys {
            if k == apiKey {
                valid = true
                break
            }
        }
        
        if !valid {
            c.AbortWithStatusJSON(403, gin.H{"error": "invalid api key"})
            return
        }
        
        c.Next()
    }
}

// 2. ä½¿ç”¨ä¸­é—´ä»¶
func RegisterReadOnlyRoutes(r *gin.Engine, repo *pg.Repository, apiKeys []string) {
    api := r.Group("/api")
    api.Use(APIKeyAuth(apiKeys))  // âœ… åº”ç”¨è®¤è¯
    {
        api.GET("/devices", ...)
        api.GET("/orders", ...)
    }
}

// 3. JWTè®¤è¯ï¼ˆæ›´å®‰å…¨ï¼‰
func JWTAuth(secret string) gin.HandlerFunc {
    return func(c *gin.Context) {
        token := c.GetHeader("Authorization")
        claims, err := jwt.Parse(token, secret)
        if err != nil {
            c.AbortWithStatusJSON(401, gin.H{"error": "invalid token"})
            return
        }
        
        c.Set("user_id", claims.UserID)
        c.Set("role", claims.Role)
        c.Next()
    }
}
```

**å·¥ä½œé‡**: 2-3å¤©  
**ä¼˜å…ˆçº§**: ğŸ”´ é«˜ï¼ˆç”Ÿäº§å¿…é¡»ï¼‰

---

### 3.9 ğŸ“¦ Repositoryç›´æ¥æš´éœ²Pool

**é—®é¢˜æè¿°**:

```go
// internal/storage/pg/repo.go
type Repository struct {
    Pool *pgxpool.Pool  // âŒ å…¬å¼€å­—æ®µï¼Œç ´åå°è£…
}

// å¤–éƒ¨å¯ä»¥ç›´æ¥è®¿é—®
repo.Pool.Query(...)  // âŒ ç»•è¿‡Repositoryå±‚
```

**å½±å“**:

- âŒ **å°è£…ç ´å**ï¼šæ— æ³•æ§åˆ¶æ•°æ®åº“è®¿é—®
- âŒ **äº‹åŠ¡å›°éš¾**ï¼šæ— æ³•ç»Ÿä¸€äº‹åŠ¡ç®¡ç†
- âŒ **æµ‹è¯•å›°éš¾**ï¼šæ— æ³•mockæ•°æ®åº“
- âŒ **é€»è¾‘æ³„æ¼**ï¼šä¸šåŠ¡é€»è¾‘ç›´æ¥å†™SQL

**æ”¹è¿›æ–¹æ¡ˆ**:

```go
// 1. å°è£…Pool
type Repository struct {
    pool *pgxpool.Pool  // âœ… ç§æœ‰å­—æ®µ
}

// 2. æä¾›äº‹åŠ¡æ¥å£
type TxFn func(context.Context, pgx.Tx) error

func (r *Repository) WithTx(ctx context.Context, fn TxFn) error {
    tx, err := r.pool.Begin(ctx)
    if err != nil {
        return err
    }
    
    if err := fn(ctx, tx); err != nil {
        tx.Rollback(ctx)
        return err
    }
    
    return tx.Commit(ctx)
}

// 3. ä½¿ç”¨äº‹åŠ¡
func (h *Handlers) HandleChargingEnd(ctx context.Context, frame *Frame) error {
    return h.Repo.WithTx(ctx, func(ctx context.Context, tx pgx.Tx) error {
        // ç»“ç®—è®¢å•
        if err := h.Repo.SettleOrderTx(ctx, tx, ...); err != nil {
            return err
        }
        
        // æ›´æ–°ç«¯å£çŠ¶æ€
        if err := h.Repo.UpdatePortStateTx(ctx, tx, ...); err != nil {
            return err
        }
        
        // âœ… åŸå­æ€§ä¿è¯
        return nil
    })
}
```

**å·¥ä½œé‡**: 2-3å¤©  
**ä¼˜å…ˆçº§**: ğŸŸ¡ ä¸­

---

### 3.10 ğŸ“Š å¥åº·æ£€æŸ¥æ·±åº¦ä¸è¶³

**é—®é¢˜æè¿°**:

```go
// internal/health/ready.go
type Ready struct {
    tcpReady bool
    dbReady  bool
}

func (r *Ready) Ready() bool {
    return r.tcpReady && r.dbReady  // âŒ ä»…æ£€æŸ¥å¯åŠ¨çŠ¶æ€
}

// GET /health è¿”å›ï¼š
// {"status": "healthy"}  // âŒ ä¿¡æ¯ä¸è¶³
```

**å½±å“**:

- âŒ **æ— æ³•è¯†åˆ«éƒ¨åˆ†æ•…éšœ**ï¼šDBæ…¢æŸ¥è¯¢æ— æ³•å‘ç°
- âŒ **è´Ÿè½½å‡è¡¡è¯¯å¯¼**ï¼šä¸å¥åº·å®ä¾‹ç»§ç»­æ¥æ”¶æµé‡
- âŒ **ç›‘æ§ç›²åŒº**ï¼šæ— æ³•æå‰é¢„è­¦

**æ”¹è¿›æ–¹æ¡ˆ**:

```go
// 1. æ·±åº¦å¥åº·æ£€æŸ¥
type HealthChecker struct {
    db      *pgxpool.Pool
    session *session.Manager
}

func (h *HealthChecker) Check(ctx context.Context) HealthStatus {
    status := HealthStatus{
        Healthy: true,
        Checks:  make(map[string]CheckResult),
    }
    
    // æ£€æŸ¥æ•°æ®åº“è¿æ¥
    dbCtx, cancel := context.WithTimeout(ctx, 2*time.Second)
    defer cancel()
    
    if err := h.db.Ping(dbCtx); err != nil {
        status.Healthy = false
        status.Checks["database"] = CheckResult{
            Status: "unhealthy",
            Error:  err.Error(),
        }
    } else {
        status.Checks["database"] = CheckResult{Status: "healthy"}
    }
    
    // æ£€æŸ¥æ•°æ®åº“æ€§èƒ½
    start := time.Now()
    var count int
    if err := h.db.QueryRow(ctx, "SELECT COUNT(*) FROM devices").Scan(&count); err == nil {
        latency := time.Since(start)
        if latency > 100*time.Millisecond {
            status.Checks["database_performance"] = CheckResult{
                Status:  "degraded",
                Latency: latency.String(),
            }
        } else {
            status.Checks["database_performance"] = CheckResult{
                Status:  "healthy",
                Latency: latency.String(),
            }
        }
    }
    
    // æ£€æŸ¥ä¼šè¯ç®¡ç†
    onlineCount := h.session.OnlineCount(time.Now())
    status.Checks["sessions"] = CheckResult{
        Status: "healthy",
        Metadata: map[string]interface{}{
            "online_devices": onlineCount,
        },
    }
    
    return status
}

// 2. å“åº”ç¤ºä¾‹
// {
//   "healthy": true,
//   "checks": {
//     "database": {"status": "healthy"},
//     "database_performance": {"status": "healthy", "latency": "15ms"},
//     "sessions": {"status": "healthy", "metadata": {"online_devices": 1234}}
//   }
// }
```

**å·¥ä½œé‡**: 1-2å¤©  
**ä¼˜å…ˆçº§**: ğŸŸ¡ ä¸­

---

## å››ã€æŠ€æœ¯å€ºåŠ¡è¯„ä¼°

### 4.1 æŠ€æœ¯å€ºåŠ¡æ¸…å•

| ä¼˜å…ˆçº§ | é—®é¢˜ | å·¥ä½œé‡ | å½±å“èŒƒå›´ | é£é™©ç­‰çº§ |
|-------|-----|--------|---------|---------|
| ğŸ”´ **P0** | ä¼šè¯çŠ¶æ€æ— æ³•æ‰©å±• | 3-5å¤© | æ¶æ„ | é«˜ |
| ğŸ”´ **P0** | å‚æ•°å­˜å‚¨ä¸´æ—¶æ–¹æ¡ˆ | 1å¤© | åŠŸèƒ½ | é«˜ |
| ğŸ”´ **P0** | å¯åŠ¨é¡ºåºç¼ºé™· | 0.5å¤© | ç¨³å®šæ€§ | ä¸­ |
| ğŸ”´ **P0** | ç¼ºå°‘APIè®¤è¯ | 2-3å¤© | å®‰å…¨ | é«˜ |
| ğŸŸ¡ **P1** | Outboundæ€§èƒ½ç“¶é¢ˆ | 5-7å¤© | æ€§èƒ½ | ä¸­ |
| ğŸŸ¡ **P1** | ä¾èµ–æ³¨å…¥å¯æµ‹è¯•æ€§ | 3-5å¤© | è´¨é‡ | ä½ |
| ğŸŸ¡ **P1** | ç¼ºå°‘é™æµæ–­è·¯å™¨ | 2-3å¤© | ç¨³å®šæ€§ | ä¸­ |
| ğŸŸ¡ **P1** | Repositoryå°è£…é—®é¢˜ | 2-3å¤© | æ¶æ„ | ä½ |
| ğŸŸ¡ **P1** | å¥åº·æ£€æŸ¥æ·±åº¦ | 1-2å¤© | è¿ç»´ | ä½ |
| ğŸŸ¢ **P2** | ç¼ºå°‘åˆ†å¸ƒå¼è¿½è¸ª | 3-5å¤© | å¯è§‚æµ‹æ€§ | ä½ |

### 4.2 æŠ€æœ¯å€ºåŠ¡æ€»è®¡

- **é«˜é£é™©é—®é¢˜**: 4ä¸ª
- **é¢„è®¡ä¿®å¤æ—¶é—´**: 6.5-11å¤©ï¼ˆP0ï¼‰
- **å»ºè®®ä¿®å¤é¡ºåº**: P0 â†’ P1 â†’ P2

---

## äº”ã€æ”¹è¿›è·¯çº¿å›¾

### Phase 1: ç´§æ€¥ä¿®å¤ (1-2å‘¨)

**ç›®æ ‡**: ä¿®å¤é«˜é£é™©é—®é¢˜

- [ ] ä¿®å¤å¯åŠ¨é¡ºåºé—®é¢˜ï¼ˆ0.5å¤©ï¼‰
- [ ] å®ç°å‚æ•°æŒä¹…åŒ–å­˜å‚¨ï¼ˆ1å¤©ï¼‰
- [ ] æ·»åŠ API Keyè®¤è¯ï¼ˆ2-3å¤©ï¼‰
- [ ] å®ç°ä¼šè¯RedisåŒ–ï¼ˆ3-5å¤©ï¼‰

### Phase 2: æ€§èƒ½ä¼˜åŒ– (2-3å‘¨)

**ç›®æ ‡**: æå‡ç³»ç»Ÿæ€§èƒ½

- [ ] æ›¿æ¢Outboundé˜Ÿåˆ—ä¸ºRedisï¼ˆ5-7å¤©ï¼‰
- [ ] å®ç°è¿æ¥é™æµå’Œæ–­è·¯å™¨ï¼ˆ2-3å¤©ï¼‰
- [ ] ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢ï¼ˆ1-2å¤©ï¼‰
- [ ] å¢åŠ å¥åº·æ£€æŸ¥æ·±åº¦ï¼ˆ1-2å¤©ï¼‰

### Phase 3: æ¶æ„é‡æ„ (3-4å‘¨)

**ç›®æ ‡**: æå‡ä»£ç è´¨é‡

- [ ] é‡æ„ä¾èµ–æ³¨å…¥ä¸ºæ¥å£ï¼ˆ3-5å¤©ï¼‰
- [ ] å°è£…Repositoryå±‚ï¼ˆ2-3å¤©ï¼‰
- [ ] å¢åŠ å•å…ƒæµ‹è¯•è¦†ç›–ç‡ï¼ˆ5-7å¤©ï¼‰
- [ ] é›†æˆæµ‹è¯•è‡ªåŠ¨åŒ–ï¼ˆ3-5å¤©ï¼‰

### Phase 4: å¯è§‚æµ‹æ€§å¢å¼º (1-2å‘¨)

**ç›®æ ‡**: æå‡è¿ç»´èƒ½åŠ›

- [ ] é›†æˆOpenTelemetryï¼ˆ3-5å¤©ï¼‰
- [ ] å®Œå–„ç›‘æ§é¢æ¿ï¼ˆ2-3å¤©ï¼‰
- [ ] å‘Šè­¦è§„åˆ™é…ç½®ï¼ˆ1-2å¤©ï¼‰

---

## å…­ã€æœ€ä½³å®è·µå»ºè®®

### 6.1 ç«‹å³å¯åšçš„æ”¹è¿› âœ…

1. **é…ç½®æ ¡éªŒ**

```go
func (c *Config) Validate() error {
    if c.TCP.MaxConnections <= 0 {
        return errors.New("tcp.maxConnections must > 0")
    }
    if c.Database.DSN == "" {
        return errors.New("database.dsn required")
    }
    return nil
}
```

2. **é”™è¯¯å°è£…**

```go
var (
    ErrDeviceNotFound = errors.New("device not found")
    ErrInvalidFrame   = errors.New("invalid frame")
    ErrDBConnection   = errors.New("database connection failed")
)
```

3. **ç»Ÿä¸€æ—¥å¿—æ ¼å¼**

```go
logger.Info("message",
    zap.String("component", "gateway"),
    zap.String("action", "handle_message"),
    zap.String("phy_id", phyID),
    zap.Int("cmd", cmd),
    zap.Duration("duration", elapsed),
)
```

### 6.2 ä»£ç è§„èŒƒ

1. **æ¥å£ä¼˜å…ˆ**ï¼šå…ˆå®šä¹‰æ¥å£ï¼Œå†å®ç°
2. **é”™è¯¯å¤„ç†**ï¼šä¸è¦å¿½ç•¥error
3. **ä¸Šä¸‹æ–‡ä¼ é€’**ï¼šæ‰€æœ‰IOæ“ä½œæ¥å—context.Context
4. **å‘½åè§„èŒƒ**ï¼šéµå¾ªGoæ ‡å‡†å‘½å
5. **æ³¨é‡Šå®Œæ•´**ï¼šå…¬å¼€æ¥å£å¿…é¡»æœ‰æ³¨é‡Š

---

## ä¸ƒã€æ€»ç»“

### 7.1 ç°çŠ¶

å½“å‰æ¶æ„**é€‚ç”¨äºä¸­å°è§„æ¨¡éƒ¨ç½²**ï¼ˆå•æœº/å°é›†ç¾¤ï¼‰ï¼Œå…·æœ‰ï¼š

- âœ… æ¸…æ™°çš„åˆ†å±‚è®¾è®¡
- âœ… è‰¯å¥½çš„å¯æ‰©å±•æ€§ï¼ˆåè®®å±‚é¢ï¼‰
- âœ… åŸºæœ¬çš„ç›‘æ§èƒ½åŠ›

ä½†é¢ä¸´ï¼š

- âŒ æ— æ³•æ°´å¹³æ‰©å±•ï¼ˆä¼šè¯å†…å­˜åŒ–ï¼‰
- âŒ æ€§èƒ½ç“¶é¢ˆï¼ˆPGæ¶ˆæ¯é˜Ÿåˆ—ï¼‰
- âŒ å®‰å…¨æ€§ä¸è¶³ï¼ˆæ— è®¤è¯ï¼‰

### 7.2 å»ºè®®

1. **çŸ­æœŸï¼ˆ1ä¸ªæœˆå†…ï¼‰**:
   - ä¿®å¤P0é—®é¢˜ï¼ˆå¯åŠ¨é¡ºåºã€å‚æ•°å­˜å‚¨ã€APIè®¤è¯ï¼‰
   - å®Œæˆä¼šè¯RedisåŒ–

2. **ä¸­æœŸï¼ˆ3ä¸ªæœˆå†…ï¼‰**:
   - ä¼˜åŒ–Outboundé˜Ÿåˆ—æ€§èƒ½
   - å®Œå–„é™æµå’Œæ–­è·¯å™¨
   - æå‡ä»£ç å¯æµ‹è¯•æ€§

3. **é•¿æœŸï¼ˆ6ä¸ªæœˆå†…ï¼‰**:
   - æ¶æ„é‡æ„ï¼ˆæ¥å£åŒ–ï¼‰
   - å¾®æœåŠ¡æ‹†åˆ†å‡†å¤‡
   - å®Œæ•´çš„å¯è§‚æµ‹æ€§ä½“ç³»

### 7.3 å…³é”®æŒ‡æ ‡

**æ”¹è¿›å‰**:

- æ°´å¹³æ‰©å±•: âŒ ä¸æ”¯æŒ
- å•æœºåå: ~1,000 msg/s
- å¯ç”¨æ€§: 99%
- æµ‹è¯•è¦†ç›–ç‡: ~20%

**æ”¹è¿›åï¼ˆé¢„æœŸï¼‰**:

- æ°´å¹³æ‰©å±•: âœ… æ”¯æŒ
- å•æœºåå: ~5,000 msg/s
- å¯ç”¨æ€§: 99.9%
- æµ‹è¯•è¦†ç›–ç‡: ~70%

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-10-05  
**ä¸‹æ¬¡è¯„å®¡**: 2025-11-05
