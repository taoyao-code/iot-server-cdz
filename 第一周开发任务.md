# 第一周开发任务 - 充电控制API实现

**任务周期**: Week 1 (5个工作日)  
**核心目标**: 实现第三方平台控制充电桩的基础API  
**优先级**: P0 (最高优先级)

## 🎯 本周目标

实现最核心的充电控制API，使第三方平台能够：
- 通过API启动充电（支持按时间/按电量模式）
- 通过API停止充电
- 查询设备和端口的实时状态
- 接收基础的事件推送

## 📅 日程安排

### Day 1 (周一): 环境准备和数据模型设计

#### 上午: 开发环境准备
- [ ] **代码分支管理**
  ```bash
  # 创建功能分支
  git checkout -b feature/third-party-api
  
  # 检查当前构建状态
  make build
  make test
  ```

- [ ] **依赖检查和安装**
  ```bash
  # 检查当前Go版本和依赖
  go version
  go mod tidy
  
  # 可能需要的新依赖
  go get github.com/go-playground/validator/v10  # 参数验证
  go get github.com/stretchr/testify/assert      # 测试框架
  ```

#### 下午: 数据模型扩展
- [ ] **数据库迁移设计**
  ```sql
  -- 创建迁移文件: db/migrations/002_add_third_party_api.up.sql
  
  -- 扩展订单表支持第三方业务
  ALTER TABLE orders ADD COLUMN IF NOT EXISTS third_party_order_no VARCHAR(100);
  ALTER TABLE orders ADD COLUMN IF NOT EXISTS third_party_user_id VARCHAR(100);
  ALTER TABLE orders ADD COLUMN IF NOT EXISTS api_client_id VARCHAR(50);
  ALTER TABLE orders ADD COLUMN IF NOT EXISTS request_source VARCHAR(20) DEFAULT 'api';
  
  -- 创建API请求日志表
  CREATE TABLE IF NOT EXISTS api_requests (
      id BIGSERIAL PRIMARY KEY,
      request_id VARCHAR(100) UNIQUE NOT NULL,
      method VARCHAR(10) NOT NULL,
      endpoint VARCHAR(200) NOT NULL,
      device_phy_id VARCHAR(50),
      client_id VARCHAR(50),
      request_body JSONB,
      response_body JSONB,
      status_code INT,
      duration_ms INT,
      client_ip VARCHAR(45),
      created_at TIMESTAMP DEFAULT NOW()
  );
  
  -- 添加索引
  CREATE INDEX IF NOT EXISTS idx_orders_third_party_order ON orders(third_party_order_no);
  CREATE INDEX IF NOT EXISTS idx_api_requests_device_time ON api_requests(device_phy_id, created_at);
  ```

- [ ] **Repository接口扩展**
  ```go
  // internal/storage/pg/third_party.go
  // 创建第三方API相关的数据访问方法
  
  func (r *Repository) CreateAPIRequest(ctx context.Context, req *APIRequest) error
  func (r *Repository) GetOrderByThirdPartyNo(ctx context.Context, orderNo string) (*Order, error) 
  func (r *Repository) UpdateOrderWithThirdPartyInfo(ctx context.Context, orderID int64, thirdPartyOrderNo, userID string) error
  ```

**Day 1 交付物**:
- 开发环境就绪，所有测试通过
- 数据库迁移脚本完成
- Repository接口扩展完成

### Day 2 (周二): API框架和路由设计

#### 上午: API框架搭建
- [ ] **创建第三方API路由结构**
  ```go
  // internal/api/third/ 目录结构
  third/
  ├── middleware.go      // 认证、限流、日志中间件
  ├── charging.go        // 充电控制处理器
  ├── device.go          // 设备查询处理器  
  ├── response.go        // 统一响应格式
  ├── validator.go       // 请求参数验证
  └── routes.go          // 路由注册
  ```

- [ ] **统一响应格式定义**
  ```go
  // internal/api/third/response.go
  type APIResponse struct {
      Code      int         `json:"code"`
      Message   string      `json:"message"`
      Data      interface{} `json:"data,omitempty"`
      RequestID string      `json:"request_id,omitempty"`
      Timestamp int64       `json:"timestamp"`
  }
  
  func RespondSuccess(c *gin.Context, data interface{})
  func RespondError(c *gin.Context, code int, message string)
  func RespondValidationError(c *gin.Context, err error)
  ```

#### 下午: 认证和中间件
- [ ] **API Key认证中间件**
  ```go
  // internal/api/third/middleware.go
  func APIKeyAuthMiddleware() gin.HandlerFunc {
      return func(c *gin.Context) {
          apiKey := c.GetHeader("X-API-Key")
          if !isValidAPIKey(apiKey) {
              RespondError(c, 401, "invalid api key")
              c.Abort()
              return
          }
          c.Set("api_client_id", getClientID(apiKey))
          c.Next()
      }
  }
  
  func RequestLoggingMiddleware() gin.HandlerFunc
  func RateLimitMiddleware() gin.HandlerFunc  
  ```

- [ ] **路由注册**
  ```go
  // internal/api/third/routes.go
  func RegisterThirdPartyRoutes(r *gin.Engine, deps *Dependencies) {
      third := r.Group("/api/third")
      third.Use(APIKeyAuthMiddleware())
      third.Use(RequestLoggingMiddleware())
      third.Use(RateLimitMiddleware())
      
      // 充电控制
      third.POST("/devices/:phyId/charge/start", chargingHandler.StartCharging)
      third.POST("/devices/:phyId/charge/stop", chargingHandler.StopCharging)
      third.GET("/devices/:phyId/charge/status", chargingHandler.GetChargingStatus)
      
      // 设备查询
      third.GET("/devices", deviceHandler.ListDevices)
      third.GET("/devices/:phyId", deviceHandler.GetDevice)
      third.GET("/devices/:phyId/ports", deviceHandler.GetPorts)
  }
  ```

**Day 2 交付物**:
- API框架和路由结构完成
- 认证和中间件实现完成
- 基础的响应格式和错误处理

### Day 3 (周三): 充电控制API实现

#### 上午: 充电启动API
- [ ] **请求参数定义和验证**
  ```go
  // internal/api/third/charging.go
  type StartChargingRequest struct {
      PortNo       int    `json:"port_no" binding:"required,min=1,max=8"`
      Mode         int    `json:"mode" binding:"required,oneof=1 2"`  // 1:按时间 2:按电量
      TimeLimit    int    `json:"time_limit,omitempty" binding:"omitempty,min=1,max=1440"`  // 分钟
      EnergyLimit  int    `json:"energy_limit,omitempty" binding:"omitempty,min=1,max=100"` // kWh
      OrderNo      string `json:"order_no" binding:"required,min=8,max=50"`
      UserID       string `json:"user_id,omitempty" binding:"omitempty,max=50"`
  }
  
  type StartChargingResponse struct {
      OrderID         int64  `json:"order_id"`
      Status          string `json:"status"`
      EstimatedStart  string `json:"estimated_start_time"`
      CommandSent     bool   `json:"command_sent"`
  }
  ```

- [ ] **充电控制处理器实现**
  ```go
  func (h *ChargingHandler) StartCharging(c *gin.Context) {
      var req StartChargingRequest
      if err := c.ShouldBindJSON(&req); err != nil {
          RespondValidationError(c, err)
          return
      }
      
      phyID := c.Param("phyId")
      clientID := c.GetString("api_client_id")
      
      // 1. 验证设备状态
      device, err := h.repo.GetDeviceByPhyID(c.Request.Context(), phyID)
      if err != nil {
          RespondError(c, 2001, "设备不存在")
          return
      }
      
      if !h.session.IsOnline(phyID) {
          RespondError(c, 2002, "设备离线")
          return
      }
      
      // 2. 验证端口状态
      port, err := h.repo.GetPortByDeviceAndNo(c.Request.Context(), device.ID, req.PortNo)
      if err != nil || port.Status != 0 { // 0:空闲
          RespondError(c, 2003, "端口不可用")
          return
      }
      
      // 3. 创建订单
      order := &Order{
          DeviceID:           device.ID,
          PhyID:             phyID,
          PortNo:            req.PortNo,
          ThirdPartyOrderNo: req.OrderNo,
          ThirdPartyUserID:  req.UserID,
          APIClientID:       clientID,
          Mode:              req.Mode,
          TimeLimit:         req.TimeLimit,
          EnergyLimit:       req.EnergyLimit,
          Status:            1, // 进行中
          RequestSource:     "api",
      }
      
      if err := h.repo.CreateOrder(c.Request.Context(), order); err != nil {
          RespondError(c, 5001, "创建订单失败")
          return
      }
      
      // 4. 发送充电指令
      success := h.sendChargingCommand(device, &req, order.ID)
      
      RespondSuccess(c, StartChargingResponse{
          OrderID:        order.ID,
          Status:         "commanding",
          EstimatedStart: time.Now().Add(3 * time.Second).Format(time.RFC3339),
          CommandSent:    success,
      })
  }
  ```

#### 下午: 设备指令集成
- [ ] **集成现有协议处理器**
  ```go
  func (h *ChargingHandler) sendChargingCommand(device *Device, req *StartChargingRequest, orderID int64) bool {
      switch device.Protocol {
      case "bkv":
          return h.sendBKVChargingCommand(device.PhyID, req, orderID)
      case "gn":
          return h.sendGNChargingCommand(device.PhyID, req, orderID)
      case "ap3000":
          return h.sendAP3000ChargingCommand(device.PhyID, req, orderID)
      default:
          h.logger.Error("unsupported protocol", zap.String("protocol", device.Protocol))
          return false
      }
  }
  
  func (h *ChargingHandler) sendBKVChargingCommand(phyID string, req *StartChargingRequest, orderID int64) bool {
      // 构造BKV协议控制指令
      controlData := bkv.ControlData{
          PortNo:      req.PortNo,
          Switch:      1, // 开启
          Mode:        req.Mode,
          TimeLimit:   req.TimeLimit,
          EnergyLimit: req.EnergyLimit,
      }
      
      payload := bkv.BuildControlPayload(controlData)
      
      // 加入出站队列，关联订单ID
      return h.outbound.EnqueueCommand(phyID, bkv.CmdControl, payload, orderID) == nil
  }
  ```

**Day 3 交付物**:
- 充电启动API完整实现
- 设备指令集成完成
- 基础的请求验证和错误处理

### Day 4 (周四): 停止充电和状态查询API

#### 上午: 停止充电API
- [ ] **停止充电API实现**
  ```go
  type StopChargingRequest struct {
      PortNo  int    `json:"port_no" binding:"required,min=1,max=8"`
      Reason  string `json:"reason" binding:"required,oneof=user_stop timeout emergency maintenance"`
      OrderNo string `json:"order_no" binding:"required"`
  }
  
  func (h *ChargingHandler) StopCharging(c *gin.Context) {
      var req StopChargingRequest
      if err := c.ShouldBindJSON(&req); err != nil {
          RespondValidationError(c, err)
          return
      }
      
      phyID := c.Param("phyId")
      
      // 1. 查找对应的充电订单
      order, err := h.repo.GetOrderByThirdPartyNo(c.Request.Context(), req.OrderNo)
      if err != nil {
          RespondError(c, 3001, "订单不存在")
          return
      }
      
      if order.PhyID != phyID || order.PortNo != req.PortNo {
          RespondError(c, 3002, "订单信息不匹配")
          return
      }
      
      if order.Status != 1 { // 1:进行中
          RespondError(c, 3003, "订单状态不允许停止")
          return
      }
      
      // 2. 发送停止指令
      success := h.sendStopCommand(order, req.Reason)
      
      // 3. 更新订单状态
      if success {
          order.Status = 2 // 已完成
          order.EndReason = req.Reason
          h.repo.UpdateOrder(c.Request.Context(), order)
      }
      
      RespondSuccess(c, gin.H{
          "status": "stopping",
          "command_sent": success,
      })
  }
  ```

#### 下午: 状态查询API
- [ ] **充电状态查询**
  ```go
  type ChargingStatusResponse struct {
      OrderID      int64   `json:"order_id"`
      OrderNo      string  `json:"order_no"`
      Status       int     `json:"status"`       // 1:进行中 2:已完成 3:异常
      StartTime    string  `json:"start_time"`
      Duration     int     `json:"duration"`     // 秒
      EnergyUsed   float64 `json:"energy_used"`  // kWh
      CurrentPower int     `json:"current_power"` // W
      Voltage      float64 `json:"voltage"`      // V
      Current      float64 `json:"current"`      // A
  }
  
  func (h *ChargingHandler) GetChargingStatus(c *gin.Context) {
      phyID := c.Param("phyId")
      portNo, _ := strconv.Atoi(c.Query("port_no"))
      
      // 查找该端口的活跃订单
      order, err := h.repo.GetActiveOrderByDevicePort(c.Request.Context(), phyID, portNo)
      if err != nil {
          RespondError(c, 3001, "未找到充电订单")
          return
      }
      
      // 获取实时端口数据
      port, _ := h.repo.GetPortByDeviceAndNo(c.Request.Context(), order.DeviceID, portNo)
      
      var duration int
      if order.StartTime != nil {
          duration = int(time.Since(*order.StartTime).Seconds())
      }
      
      response := ChargingStatusResponse{
          OrderID:      order.ID,
          OrderNo:      order.ThirdPartyOrderNo,
          Status:       order.Status,
          StartTime:    order.StartTime.Format(time.RFC3339),
          Duration:     duration,
          EnergyUsed:   float64(order.KWH01) / 100.0,
          CurrentPower: port.PowerW,
          Voltage:      float64(port.Voltage) / 10.0,
          Current:      float64(port.Current) / 1000.0,
      }
      
      RespondSuccess(c, response)
  }
  ```

**Day 4 交付物**:
- 停止充电API完成
- 充电状态查询API完成
- 订单状态管理完善

### Day 5 (周五): 测试和集成

#### 上午: 单元测试
- [ ] **API处理器测试**
  ```go
  // internal/api/third/charging_test.go
  func TestStartCharging(t *testing.T) {
      // 准备测试环境
      mockRepo := &MockRepository{}
      mockSession := &MockSessionManager{}
      handler := NewChargingHandler(mockRepo, mockSession, nil)
      
      // 测试正常流程
      t.Run("success", func(t *testing.T) {
          req := StartChargingRequest{
              PortNo:      1,
              Mode:        1,
              TimeLimit:   60,
              OrderNo:     "TEST001",
          }
          
          // 模拟请求
          w := httptest.NewRecorder()
          c, _ := gin.CreateTestContext(w)
          c.Set("api_client_id", "test_client")
          
          handler.StartCharging(c)
          
          assert.Equal(t, 200, w.Code)
          // 验证响应数据
      })
      
      // 测试各种异常情况
      t.Run("device_offline", func(t *testing.T) { /* ... */ })
      t.Run("port_busy", func(t *testing.T) { /* ... */ })
      t.Run("invalid_params", func(t *testing.T) { /* ... */ })
  }
  
  func TestStopCharging(t *testing.T) { /* ... */ }
  func TestGetChargingStatus(t *testing.T) { /* ... */ }
  ```

#### 下午: 集成测试和文档
- [ ] **API集成测试**
  ```bash
  # 创建集成测试脚本 scripts/test_charging_api.sh
  #!/bin/bash
  
  API_BASE="http://localhost:8080/api/third"
  API_KEY="test_api_key"
  DEVICE_ID="TEST_DEVICE_001"
  
  echo "=== 测试充电控制API ==="
  
  # 1. 查询设备状态
  curl -X GET "$API_BASE/devices/$DEVICE_ID" \
       -H "X-API-Key: $API_KEY"
  
  # 2. 启动充电
  curl -X POST "$API_BASE/devices/$DEVICE_ID/charge/start" \
       -H "X-API-Key: $API_KEY" \
       -H "Content-Type: application/json" \
       -d '{
         "port_no": 1,
         "mode": 1,
         "time_limit": 60,
         "order_no": "TEST'$(date +%s)'"
       }'
  
  # 3. 查询充电状态
  curl -X GET "$API_BASE/devices/$DEVICE_ID/charge/status?port_no=1" \
       -H "X-API-Key: $API_KEY"
  
  # 4. 停止充电
  curl -X POST "$API_BASE/devices/$DEVICE_ID/charge/stop" \
       -H "X-API-Key: $API_KEY" \
       -H "Content-Type: application/json" \
       -d '{
         "port_no": 1,
         "reason": "user_stop",
         "order_no": "TEST123456"
       }'
  ```

- [ ] **API文档更新**
  ```yaml
  # 更新 api/openapi/openapi.yaml
  paths:
    /api/third/devices/{phyId}/charge/start:
      post:
        summary: 启动充电
        parameters:
          - in: path
            name: phyId
            required: true
            schema:
              type: string
        requestBody:
          required: true
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StartChargingRequest'
        responses:
          '200':
            description: 成功
            content:
              application/json:
                schema:
                  $ref: '#/components/schemas/APIResponse'
  ```

**Day 5 交付物**:
- 完整的单元测试套件
- API集成测试脚本
- API文档更新
- 代码review和质量检查

## 🎯 Week 1 最终交付标准

### 功能验收
- [ ] 第三方平台可以通过API启动充电（成功率>95%）
- [ ] 第三方平台可以通过API停止充电
- [ ] 可以实时查询充电状态和进度
- [ ] API响应时间 P95 < 100ms
- [ ] 所有异常情况都有合适的错误码和提示

### 代码质量
- [ ] 单元测试覆盖率 > 80%
- [ ] 代码review通过
- [ ] 遵循项目编码规范
- [ ] 完整的错误处理和日志记录

### 技术验收
- [ ] 集成测试脚本可以成功执行
- [ ] API文档准确且示例可运行
- [ ] 与现有协议处理器正确集成
- [ ] 数据库迁移可以无损执行

## 🚀 Week 2 预告

**下周重点**:
- 设备管理API（参数设置、远程重启）
- 批量操作API
- 事件推送机制实现
- 性能优化和缓存策略

---

**立即开始**: 按照Day 1的任务清单开始开发，有问题随时沟通调整