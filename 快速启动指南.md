# 快速启动指南 - 阶段1开发

本指南将帮助你立即开始阶段1的开发工作，从用户管理系统开始构建完整的物联网充电桩平台。

## 🚀 立即开始

### 第1步：环境准备

```bash
# 1. 确保依赖已安装
go mod tidy

# 2. 安装新依赖
go get github.com/golang-jwt/jwt/v5
go get github.com/casbin/casbin/v2
go get github.com/go-redis/redis/v8
go get golang.org/x/crypto/bcrypt

# 3. 更新 go.mod
```

### 第2步：配置文件扩展

```yaml
# configs/config.yaml - 新增以下配置
auth:
  jwt_secret: "your-very-secure-secret-key-here"
  jwt_expire: "24h"
  refresh_expire: "720h"

redis:
  addr: "localhost:6379"
  password: ""
  db: 1

payment:
  wechat:
    app_id: "your-wechat-app-id"
    merchant_id: "your-merchant-id" 
    api_key: "your-api-key"
    notify_url: "https://yourdomain.com/api/v1/payments/wechat/notify"

billing:
  default_strategy_id: 1
  currency: "CNY"
```

### 第3步：数据库迁移

```bash
# 创建迁移文件
mkdir -p db/migrations

# 执行第一个业务迁移
cat > db/migrations/002_add_user_management.up.sql << 'EOF'
-- 用户表
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    phone VARCHAR(20) UNIQUE,
    email VARCHAR(100) UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    status SMALLINT DEFAULT 1,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 角色表  
CREATE TABLE roles (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    description TEXT,
    permissions JSONB,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 用户角色关联
CREATE TABLE user_roles (
    user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
    role_id BIGINT REFERENCES roles(id) ON DELETE CASCADE,
    created_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (user_id, role_id)
);

-- 扩展订单表
ALTER TABLE orders ADD COLUMN user_id BIGINT REFERENCES users(id);
ALTER TABLE orders ADD COLUMN charging_mode SMALLINT;
ALTER TABLE orders ADD COLUMN estimated_amount_cent BIGINT;

-- 插入默认角色
INSERT INTO roles (name, description, permissions) VALUES 
('admin', '系统管理员', '["*"]'),
('user', '普通用户', '["charging.start", "charging.stop", "order.read"]');
EOF

# 运行迁移 (根据你的迁移工具调整命令)
# migrate -path db/migrations -database "postgres://user:pass@localhost/dbname?sslmode=disable" up
```

### 第4步：项目结构创建

```bash
# 创建新的目录结构
mkdir -p internal/auth
mkdir -p internal/billing  
mkdir -p internal/business
mkdir -p internal/api/v1
mkdir -p configs/rbac

# 创建基础文件
touch internal/auth/jwt.go
touch internal/auth/rbac.go
touch internal/auth/middleware.go
touch internal/billing/engine.go
touch internal/business/user.go
touch internal/api/v1/auth.go
```

### 第5步：基础代码实现

#### 5.1 JWT认证模块

```bash
# 创建 internal/auth/jwt.go
cat > internal/auth/jwt.go << 'EOF'
package auth

import (
    "time"
    "github.com/golang-jwt/jwt/v5"
    "github.com/gin-gonic/gin"
    "strings"
)

type JWTClaims struct {
    UserID   int64  `json:"user_id"`
    Username string `json:"username"`
    jwt.RegisteredClaims
}

type JWTManager struct {
    secretKey     []byte
    tokenExpire   time.Duration
    refreshExpire time.Duration
}

func NewJWTManager(secret string, tokenExpire, refreshExpire time.Duration) *JWTManager {
    return &JWTManager{
        secretKey:     []byte(secret),
        tokenExpire:   tokenExpire,
        refreshExpire: refreshExpire,
    }
}

func (j *JWTManager) GenerateToken(userID int64, username string) (string, error) {
    claims := &JWTClaims{
        UserID:   userID,
        Username: username,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(j.tokenExpire)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(j.secretKey)
}

func (j *JWTManager) ParseToken(tokenString string) (*JWTClaims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &JWTClaims{}, func(token *jwt.Token) (interface{}, error) {
        return j.secretKey, nil
    })
    
    if err != nil {
        return nil, err
    }
    
    claims, ok := token.Claims.(*JWTClaims)
    if !ok || !token.Valid {
        return nil, jwt.ErrInvalidKey
    }
    
    return claims, nil
}

func (j *JWTManager) AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(401, gin.H{"error": "missing authorization header"})
            c.Abort()
            return
        }
        
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        claims, err := j.ParseToken(tokenString)
        if err != nil {
            c.JSON(401, gin.H{"error": "invalid token"})
            c.Abort()
            return
        }
        
        c.Set("user_id", claims.UserID)
        c.Set("username", claims.Username)
        c.Next()
    }
}
EOF
```

#### 5.2 用户管理API

```bash
# 创建 internal/api/v1/auth.go
cat > internal/api/v1/auth.go << 'EOF'
package v1

import (
    "net/http"
    "github.com/gin-gonic/gin"
    "golang.org/x/crypto/bcrypt"
    "github.com/taoyao-code/iot-server/internal/auth"
    "github.com/taoyao-code/iot-server/internal/storage/pg"
)

type AuthHandler struct {
    repo *pg.Repository
    jwt  *auth.JWTManager
}

type RegisterRequest struct {
    Username string `json:"username" binding:"required,min=3,max=50"`
    Phone    string `json:"phone" binding:"required"`
    Email    string `json:"email"`
    Password string `json:"password" binding:"required,min=6"`
}

type LoginRequest struct {
    Phone    string `json:"phone" binding:"required"`
    Password string `json:"password" binding:"required"`
}

func NewAuthHandler(repo *pg.Repository, jwt *auth.JWTManager) *AuthHandler {
    return &AuthHandler{repo: repo, jwt: jwt}
}

func (h *AuthHandler) Register(c *gin.Context) {
    var req RegisterRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // 检查用户是否已存在
    if _, err := h.repo.GetUserByPhone(c.Request.Context(), req.Phone); err == nil {
        c.JSON(http.StatusConflict, gin.H{"error": "user already exists"})
        return
    }
    
    // 密码哈希
    passwordHash, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to hash password"})
        return
    }
    
    // 创建用户
    user := &pg.User{
        Username:     req.Username,
        Phone:        req.Phone,
        Email:        req.Email,
        PasswordHash: string(passwordHash),
        Status:       1,
    }
    
    if err := h.repo.CreateUser(c.Request.Context(), user); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to create user"})
        return
    }
    
    // 分配默认角色
    if err := h.repo.AssignUserRole(c.Request.Context(), user.ID, 2); err != nil { // 2: user role
        // 记录日志，但不影响注册流程
    }
    
    c.JSON(http.StatusOK, gin.H{
        "message": "user created successfully",
        "user_id": user.ID,
    })
}

func (h *AuthHandler) Login(c *gin.Context) {
    var req LoginRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // 查找用户
    user, err := h.repo.GetUserByPhone(c.Request.Context(), req.Phone)
    if err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid credentials"})
        return
    }
    
    // 验证密码
    if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.Password)); err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid credentials"})
        return
    }
    
    // 检查用户状态
    if user.Status != 1 {
        c.JSON(http.StatusForbidden, gin.H{"error": "user is disabled"})
        return
    }
    
    // 生成token
    token, err := h.jwt.GenerateToken(user.ID, user.Username)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to generate token"})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "access_token": token,
        "token_type":   "Bearer",
        "user": gin.H{
            "id":       user.ID,
            "username": user.Username,
            "phone":    user.Phone,
            "email":    user.Email,
        },
    })
}

func (h *AuthHandler) GetProfile(c *gin.Context) {
    userID := c.GetInt64("user_id")
    
    user, err := h.repo.GetUserByID(c.Request.Context(), userID)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "user": gin.H{
            "id":       user.ID,
            "username": user.Username,
            "phone":    user.Phone,
            "email":    user.Email,
            "status":   user.Status,
        },
    })
}
EOF
```

#### 5.3 扩展Repository接口

```bash
# 在 internal/storage/pg/ 目录下创建用户相关方法
cat >> internal/storage/pg/repository.go << 'EOF'

// User management methods
type User struct {
    ID           int64     `json:"id"`
    Username     string    `json:"username"`
    Phone        string    `json:"phone"`
    Email        string    `json:"email"`
    PasswordHash string    `json:"-"`
    Status       int       `json:"status"`
    CreatedAt    time.Time `json:"created_at"`
    UpdatedAt    time.Time `json:"updated_at"`
}

func (r *Repository) CreateUser(ctx context.Context, user *User) error {
    query := `
        INSERT INTO users (username, phone, email, password_hash, status, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, NOW(), NOW())
        RETURNING id, created_at, updated_at`
    
    return r.db.QueryRow(ctx, query, user.Username, user.Phone, user.Email, user.PasswordHash, user.Status).
        Scan(&user.ID, &user.CreatedAt, &user.UpdatedAt)
}

func (r *Repository) GetUserByPhone(ctx context.Context, phone string) (*User, error) {
    user := &User{}
    query := `
        SELECT id, username, phone, email, password_hash, status, created_at, updated_at
        FROM users WHERE phone = $1`
    
    err := r.db.QueryRow(ctx, query, phone).Scan(
        &user.ID, &user.Username, &user.Phone, &user.Email, 
        &user.PasswordHash, &user.Status, &user.CreatedAt, &user.UpdatedAt)
    
    return user, err
}

func (r *Repository) GetUserByID(ctx context.Context, id int64) (*User, error) {
    user := &User{}
    query := `
        SELECT id, username, phone, email, password_hash, status, created_at, updated_at
        FROM users WHERE id = $1`
    
    err := r.db.QueryRow(ctx, query, id).Scan(
        &user.ID, &user.Username, &user.Phone, &user.Email, 
        &user.PasswordHash, &user.Status, &user.CreatedAt, &user.UpdatedAt)
    
    return user, err
}

func (r *Repository) AssignUserRole(ctx context.Context, userID, roleID int64) error {
    query := `INSERT INTO user_roles (user_id, role_id) VALUES ($1, $2) ON CONFLICT DO NOTHING`
    _, err := r.db.Exec(ctx, query, userID, roleID)
    return err
}
EOF
```

### 第6步：集成到主程序

```bash
# 修改 cmd/server/main.go 或主启动文件
cat >> cmd/server/main.go << 'EOF'

// 在 main 函数中添加新的路由
func setupRoutes(r *gin.Engine, repo *pgstorage.Repository) {
    // 现有路由...
    
    // JWT管理器
    jwtManager := auth.NewJWTManager(
        config.Auth.JWTSecret,
        config.Auth.JWTExpire,
        config.Auth.RefreshExpire,
    )
    
    // API v1 路由组
    v1 := r.Group("/api/v1")
    
    // 认证路由
    authHandler := v1auth.NewAuthHandler(repo, jwtManager)
    v1.POST("/auth/register", authHandler.Register)
    v1.POST("/auth/login", authHandler.Login)
    
    // 需要认证的路由
    authorized := v1.Group("/")
    authorized.Use(jwtManager.AuthMiddleware())
    {
        authorized.GET("/auth/profile", authHandler.GetProfile)
        // 后续会添加更多路由...
    }
}
EOF
```

### 第7步：测试API

```bash
# 1. 启动服务
go run cmd/server/main.go

# 2. 测试用户注册
curl -X POST http://localhost:8080/api/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "testuser",
    "phone": "13800138000", 
    "email": "test@example.com",
    "password": "password123"
  }'

# 3. 测试用户登录  
curl -X POST http://localhost:8080/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "phone": "13800138000",
    "password": "password123"
  }'

# 4. 测试获取用户信息 (使用登录返回的token)
curl -X GET http://localhost:8080/api/v1/auth/profile \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

## 📋 接下来的开发清单

### Week 1 剩余任务
- [ ] 添加用户管理的CRUD接口
- [ ] 实现角色权限管理
- [ ] 添加组织架构支持
- [ ] 完善错误处理和验证
- [ ] 编写单元测试

### Week 2 任务预览
- [ ] 计费引擎实现
- [ ] 充电订单系统
- [ ] 支付集成准备
- [ ] 设备控制API扩展

## 🛠️ 开发建议

### 代码规范
- 遵循项目现有的代码风格
- 使用统一的错误处理模式
- 添加充分的日志记录
- 保持API响应格式一致

### 测试策略
- 每个新功能都要写单元测试
- 重要的业务流程要有集成测试
- 使用testify/assert进行断言
- 保持测试覆盖率 > 80%

### 性能考虑
- 数据库查询要添加适当索引
- 热点数据考虑使用Redis缓存
- API响应时间控制在100ms以内
- 注意并发安全问题

## 🚨 注意事项

1. **数据安全**: 
   - 密码必须哈希存储
   - JWT secret要足够复杂
   - 敏感信息不要记录到日志

2. **向后兼容**:
   - 不要修改现有API的响应格式
   - 数据库迁移要可回滚
   - 新功能要考虑现有业务影响

3. **监控观测**:
   - 新API要添加metrics记录
   - 重要操作要记录audit log
   - 异常情况要有告警

## 📞 需要帮助？

如果在开发过程中遇到问题：

1. **技术问题**: 参考 `docs/技术实施指南.md` 的详细实现
2. **架构疑问**: 查看 `docs/架构设计.md` 了解整体设计
3. **业务流程**: 参考 `issues/阶段1实施计划-核心业务层.md`

---

**现在就开始**: 按照上述步骤，你可以立即开始构建用户管理系统，为完整的物联网充电桩平台奠定基础！