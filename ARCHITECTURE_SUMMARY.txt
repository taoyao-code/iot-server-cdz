================================================================================
物联网充电桩服务器 - 快速参考
================================================================================

核心数据流：
1. 入站（设备→服务器）：
   TCP → Mux（协议检测）→ Adapter（解码）→ Router（分发）
   → Handler（业务逻辑）→ DB持久化

2. 出站（服务器→设备）：
   HTTP API → ThirdPartyHandler → Redis队列（按优先级排序）
   → RedisWorker（轮询）→ Session（在线检查）→ Socket写入 → ACK

3. 会话管理：
   TCP连接 → bind(phyID) → Redis存储 + 本地缓存
   心跳 → 更新Redis中的lastSeen
   TCP关闭 → 解绑并清理

关键架构模式：
────────────────────────────────────────────────────────────────────────────
1. 协议适配器模式（可插拔协议）
   - AP3000Adapter、BKVAdapter实现Adapter接口
   - 通过第一帧的魔数检测
   - 每个协议包含：StreamDecoder + RouterTable + Handlers

2. 解耦处理器模式（非阻塞命令）
   - 处理器将命令入队到Redis，立即返回
   - RedisWorker在后台单独轮询
   - 命令在进程崩溃后仍可保留

3. 加权在线检测（多信号评分）
   - 心跳：如果新鲜则+1.0
   - TCP断开：如果最近发生则-惩罚
   - ACK超时：如果最近发生则-惩罚
   - 最终：分数≥阈值 = 在线

4. 带降级的优先级队列（背压）
   - 正常（0-200）：接受所有命令
   - 警告（200-500）：拒绝低优先级
   - 严重（500-1000）：仅接受正常/高优先级
   - 紧急（>1000）：仅接受紧急命令

启动序列（9个阶段）：
────────────────────────────────────────────────────────────────────────────
1. 指标 + 就绪跟踪器 + 服务器ID
2. Redis客户端（必需）
3. 会话管理器（使用Redis）
4. PostgreSQL数据库（必需）
5. 业务处理器（AP3000、BKV）
6. HTTP服务器（后台）
7. 出站工作线程 + 事件工作线程（后台）
8. TCP服务器（最后，阻塞）
9. 优雅关闭

关键文件：
────────────────────────────────────────────────────────────────────────────
启动：
  - cmd/server/main.go
  - internal/app/bootstrap/app.go（9阶段编排）

TCP网关：
  - internal/tcpserver/server.go（监听器）
  - internal/tcpserver/mux.go（协议检测）
  - internal/tcpserver/conn.go（连接包装器）

协议：
  - internal/protocol/ap3000/adapter.go
  - internal/protocol/bkv/adapter.go
  - internal/gateway/conn_handler.go（处理器注册）

会话管理：
  - internal/session/redis_manager.go
  - internal/session/interface.go

出站队列：
  - internal/storage/redis/outbound_queue.go（Redis操作）
  - internal/outbound/redis_worker.go（轮询和传递）
  - internal/app/outbound_adapter.go（处理器→队列桥接）

数据库：
  - internal/storage/pg/repo.go（约700行查询）
  - internal/storage/pg/pool.go（连接池）

API：
  - internal/api/thirdparty_handler.go（命令端点）
  - internal/api/readonly_handler.go（查询端点）

消息流示例：设备心跳
────────────────────────────────────────────────────────────────────────────
设备发送：0x21帧
  ↓
TCPServer接收字节
  ↓
Mux.onRead()匹配AP3000魔数
  ↓
apAdapter.ProcessBytes()解码帧
  ↓
table.Route(frame)调用handlers[0x21]
  ↓
处理器包装：
  - bindIfNeeded(phyID) → sess.Bind()
  - sess.OnHeartbeat() → 更新Redis
  - repo.EnsureDevice() → 创建设备记录
  - repo.InsertCmdLog() → 审计日志

消息流示例：启动充电（API）
────────────────────────────────────────────────────────────────────────────
HTTP POST /api/v1/third/devices/{device_id}/charge
  ↓
ThirdPartyHandler.StartCharge()
  - 验证设备在线：sess.IsOnline()
  - 在数据库中创建订单
  - 编码命令（特定协议）
  ↓
outboundAdapter.SendDownlink()
  - 构建帧
  - 计算优先级
  - 检查队列长度
  ↓
queue.Enqueue() → Redis ZADD（原子性，按优先级排序）
  ↓
RedisWorker.processOne()（每100ms轮询一次）
  - 出队最高优先级（ZPOPMIN原子操作）
  - 标记处理中
  - 查找会话：sess.GetConn() → 检查心跳超时
  - socket.Write() → 发送到设备
  - 标记成功
  ↓
设备接收，发送ACK
  ↓
处理器处理ACK
  - repo.AckOutboundByMsgID()

性能特征：
────────────────────────────────────────────────────────────────────────────
- 并发连接数：最多10,000（可配置）
- 心跳超时：5分钟（可配置）
- 队列轮询：100ms（可配置）
- 数据库：PostgreSQL，使用UPSERT确保幂等性
- 会话存储：Redis，自动TTL
- 命令传递：异步，非阻塞
- 队列原子操作：ZADD、ZPOPMIN防止重复

REDIS键模式：
────────────────────────────────────────────────────────────────────────────
session:device:{phyID}          → {connID, serverID, lastSeen, lastTCPDown, lastAckTimeout}
session:conn:{connID}           → phyID
session:server:{serverID}:conns → Set[connID]（此服务器的所有连接）
outbound:queue                  → Sorted Set（score=priority*1e12+unixnano）
outbound:processing:{phyID}     → Hash[msgID]（正在发送的消息）
outbound:dead                   → List（失败的消息）

扩展点：
────────────────────────────────────────────────────────────────────────────
1. 新协议：实现Adapter接口 + 在conn_handler.go中注册
2. 新API端点：添加到thirdparty_handler.go + thirdparty_routes.go
3. 自定义优先级：修改outbound/priority.go
4. 自定义健康检查：添加到internal/health/

故障排除快速参考：
────────────────────────────────────────────────────────────────────────────
设备离线？           → 检查Redis：session:device:{phyID}.lastSeen
出站队列堆积？       → 检查ZCARD outbound:queue，检查工作线程日志
命令未执行？         → 检查：设备在线？已入队？工作线程运行？
协议不匹配？         → 验证流的前8字节中的魔数
连接未绑定？         → 检查mux检测是否与实际协议匹配

================================================================================
详细信息请参阅：CLAUDE.md（696行）
================================================================================
