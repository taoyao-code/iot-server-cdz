# IoT充电桩服务器 - 架构文档

> **最后更新**: 2025-11-10  
> **文档版本**: v2.0 (合并版)

---

## 📋 目录

- [快速参考](#快速参考)
- [系统架构图](#系统架构图)
  - [1. 系统组件层次结构](#1-系统组件层次结构)
  - [2. 入站消息流](#2-入站消息流)
  - [3. 出站消息流](#3-出站消息流)
  - [4. 会话生命周期](#4-会话生命周期)
  - [5. 多阶段启动序列](#5-多阶段启动序列)
  - [6. 协议检测和分发](#6-协议检测和分发)
  - [7. Redis存储架构](#7-redis存储架构)
  - [8. 错误处理和重试流程](#8-错误处理和重试流程)
- [文档指南](#文档指南)
- [关键概念](#关键概念)
- [文件组织](#文件组织)
- [常见问题](#常见问题)

---

## 快速参考

### 核心数据流

**1. 入站（设备→服务器）**
```
TCP → Mux（协议检测）→ Adapter（解码）→ Router（分发）
→ Handler（业务逻辑）→ DB持久化
```

**2. 出站（服务器→设备）**
```
HTTP API → ThirdPartyHandler → Redis队列（按优先级排序）
→ RedisWorker（轮询）→ Session（在线检查）→ Socket写入 → ACK
```

**3. 会话管理**
```
TCP连接 → bind(phyID) → Redis存储 + 本地缓存
心跳 → 更新Redis中的lastSeen
TCP关闭 → 解绑并清理
```

### 关键架构模式

1. **协议适配器模式**（可插拔协议）
   - AP3000Adapter、BKVAdapter实现Adapter接口
   - 通过第一帧的魔数检测
   - 每个协议包含：StreamDecoder + RouterTable + Handlers

2. **解耦处理器模式**（非阻塞命令）
   - 处理器将命令入队到Redis，立即返回
   - RedisWorker在后台单独轮询
   - 命令在进程崩溃后仍可保留

3. **加权在线检测**（多信号评分）
   - 心跳：如果新鲜则+1.0
   - TCP断开：如果最近发生则-惩罚
   - ACK超时：如果最近发生则-惩罚
   - 最终：分数≥阈值 = 在线

4. **带降级的优先级队列**（背压）
   - 正常（0-200）：接受所有命令
   - 警告（200-500）：拒绝低优先级
   - 严重（500-1000）：仅接受正常/高优先级
   - 紧急（>1000）：仅接受紧急命令

### 启动序列（9个阶段）

1. 指标 + 就绪跟踪器 + 服务器ID
2. Redis客户端（必需）
3. 会话管理器（使用Redis）
4. PostgreSQL数据库（必需）
5. 业务处理器（AP3000、BKV）
6. HTTP服务器（后台）
7. 出站工作线程 + 事件工作线程（后台）
8. TCP服务器（最后，阻塞）
9. 优雅关闭

### Redis键模式

```
session:device:{phyID}          → {connID, serverID, lastSeen, lastTCPDown, lastAckTimeout}
session:conn:{connID}           → phyID
session:server:{serverID}:conns → Set[connID]（此服务器的所有连接）
outbound:queue                  → Sorted Set（score=priority*1e12+unixnano）
outbound:processing:{phyID}     → Hash[msgID]（正在发送的消息）
outbound:dead                   → List（失败的消息）
```

### 性能特征

- **并发连接数**: 最多10,000（可配置）
- **心跳超时**: 5分钟（可配置）
- **队列轮询**: 100ms（可配置）
- **数据库**: PostgreSQL，使用UPSERT确保幂等性
- **会话存储**: Redis，自动TTL
- **命令传递**: 异步，非阻塞
- **队列原子操作**: ZADD、ZPOPMIN防止重复

---

## 系统架构图

### 1. 系统组件层次结构

```
┌─────────────────────────────────────────────────────────────────┐
│                        IoT 服务器                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────────┐        ┌──────────────────────────┐  │
│  │   TCP 网关           │        │    HTTP 服务器           │  │
│  │ (端口 6000)          │        │ (端口 7055)              │  │
│  │                      │        │                          │  │
│  │ • 连接限制           │        │ • API 路由               │  │
│  │ • 速率限制           │        │ • 健康检查               │  │
│  │ • 熔断器             │        │ • 指标端点               │  │
│  └──────┬───────────────┘        └──────┬───────────────────┘  │
│         │                               │                      │
│         ├─► Mux (协议检测)              │                      │
│         │   • 嗅探魔术字节              │                      │
│         │   • 分发到适配器              │                      │
│         │                               │                      │
│         ├─► AP3000适配器 / BKV适配器   │                      │
│         │   • 流解码器                  │                      │
│         │   • 路由表                    │                      │
│         │   • 帧处理器                  │                      │
│         │                               │                      │
│         └─► 会话管理◄────────────────┘                      │
│             (Redis 支持)                                      │
│             • bind(phyID)                                     │
│             • GetConn()                                       │
│             • IsOnline()                                      │
│                                                               │
│  ┌────────────────────────────────────────────────────────┐  │
│  │          数据持久化层                                   │  │
│  ├────────────────────────────────────────────────────────┤  │
│  │                                                         │  │
│  │  PostgreSQL              Redis                         │  │
│  │  • devices               • session:device:{phyID}      │  │
│  │  • ports                 • outbound:queue              │  │
│  │  • orders                • outbound:processing:*       │  │
│  │  • cmd_log               • outbound:dead               │  │
│  │  • outbound_queue        • event queue                 │  │
│  │                                                         │  │
│  └────────────────────────────────────────────────────────┘  │
│                                                               │
│  ┌────────────────────────────────────────────────────────┐  │
│  │          后台工作线程 (Goroutines)                      │  │
│  ├────────────────────────────────────────────────────────┤  │
│  │ • RedisWorker (出站轮询)                                │  │
│  │ • EventQueueWorkers (webhook 推送)                     │  │
│  │ • OrderMonitor (过期订单检测)                           │  │
│  │ • PortStatusSyncer (状态监控)                          │  │
│  └────────────────────────────────────────────────────────┘  │
│                                                               │
└─────────────────────────────────────────────────────────────────┘
```

### 2. 入站消息流

**设备 → 服务器**

```
                          设备
                            ↓
                    TCP/IP 网络
                            ↓
            ┌───────────────────────────────┐
            │     TCPServer.Accept()         │
            │   监听 :6000                   │
            └───────────┬───────────────────┘
                        ↓
            ┌───────────────────────────────┐
            │   创建 ConnContext            │
            │   + 读缓冲区                  │
            │   + 写队列                    │
            └───────────┬───────────────────┘
                        ↓
            ┌───────────────────────────────┐
            │   Mux.BindToConn()            │
            │   设置 OnRead 回调            │
            └───────────┬───────────────────┘
                        ↓
        ┌───────────────────────────────────┐
        │   OnRead 被调用 (首次)            │
        │   + 检查前 8 字节 (魔术字节)      │
        ├───────────────────────────────────┤
        │  匹配?                            │
        ├─────────────────────────────────┬─┤
        │                                 │  │
        V                                 V  V
   ┌─────────────────┐         ┌──────────────────┐
   │ AP3000适配器    │         │   BKV适配器      │
   │ 魔术字节: D"N   │         │ 魔术字节: FCFE/FCFF │
   └────────┬────────┘         └────────┬─────────┘
            │                           │
            V                           V
   ┌─────────────────────────────────────────────┐
   │       StreamDecoder.Feed(bytes)             │
   │   (处理分帧、半包等)                        │
   │       → [Frame1, Frame2, ...]               │
   └────────────┬────────────────────────────────┘
                ↓
   ┌─────────────────────────────────────────────┐
   │       RouterTable.Route(frame)              │
   │   查找: handlers[frame.Cmd]                 │
   └────────────┬────────────────────────────────┘
                ↓
   ┌─────────────────────────────────────────────┐
   │   处理器执行                                 │
   │   ├─ bindIfNeeded(phyID)                    │
   │   │  └─ sess.Bind(phyID, connContext)      │
   │   ├─ sess.OnHeartbeat(phyID, now)          │
   │   ├─ Metrics: 增加计数器                   │
   │   └─ 协议特定处理器                         │
   │      • HandleRegister()                    │
   │      • HandleHeartbeat()                   │
   │      • HandleControl()                     │
   └────────────┬────────────────────────────────┘
                ↓
   ┌─────────────────────────────────────────────┐
   │   数据库持久化                              │
   │   ├─ EnsureDevice(phyID)                    │
   │   ├─ UpsertPortState(...)                   │
   │   ├─ UpsertOrderProgress(...)               │
   │   ├─ SettleOrder(...)                       │
   │   └─ InsertCmdLog(...)                      │
   └─────────────────────────────────────────────┘
```

### 3. 出站消息流

**服务器 → 设备**

```
        HTTP 客户端 (第三方或内部)
                ↓
    POST /api/v1/third/devices/{device_id}/charge
                ↓
    ┌─────────────────────────────────────────┐
    │  ThirdPartyHandler.StartCharge()        │
    │  1. 解析 JSON 请求体                    │
    │  2. 检查 sess.IsOnline(phyID)           │
    │  3. 在数据库中 CreateOrder()            │
    │  4. 构建协议命令                        │
    └──────────┬────────────────────────────────┘
               ↓
    ┌─────────────────────────────────────────┐
    │  outboundAdapter.SendDownlink()         │
    │  1. 编码帧 (bkv.Build 等)               │
    │  2. 从命令类型获取优先级                │
    │  3. 创建 OutboundMessage                │
    └──────────┬────────────────────────────────┘
               ↓
    ┌──────────────────────────────────────────────┐
    │  queue.Enqueue(msg)                         │
    │  1. 检查队列长度 (降级检查)                 │
    │  2. 计算分数: priority * 1e12 + unixnano   │
    │  3. Redis ZADD outbound:queue               │
    │  4. 返回 202 Accepted                       │
    └──────────┬────────────────────────────────────┘
               ↓
    ╔════════════════════════════════════════════════╗
    ║  RedisWorker (持续轮询，每100ms)              ║
    ╠════════════════════════════════════════════════╣
    ║  1. queue.Dequeue() → ZPOPMIN               ║
    ║  2. queue.MarkProcessing(msg)                 ║
    ║  3. sess.GetConn(msg.PhyID)                   ║
    ║  4. 连接不可用: MarkFailed + 重试             ║
    ║  5. 连接可用: connContext.Write(frame)        ║
    ║  6. 写入成功: MarkSuccess                     ║
    ║  7. 写入失败: MarkFailed + 重试               ║
    ╚════════════════════════════════════════════════╝
               ↓
            设备接收并发送ACK
               ↓
        ┌─────────────────────────────┐
        │  处理ACK帧                  │
        │  repo.AckOutboundByMsgID()  │
        └─────────────────────────────┘
```

### 4. 会话生命周期

```
                设备连接到 TCP
                        ↓
        ┌───────────────────────────────────┐
        │   TCP 连接已接受                  │
        │   创建 ConnContext                │
        └──────────┬────────────────────────┘
                   ↓
        ┌───────────────────────────────────┐
        │   接收到第一条消息                │
        │   bindIfNeeded(phyID)             │
        └──────────┬────────────────────────┘
                   ↓
        ┌───────────────────────────────────┐
        │   sess.Bind(phyID, connContext)   │
        ├───────────────────────────────────┤
        │   1. 生成 connID (UUID)           │
        │   2. 存储到 Redis:                │
        │      session:device:{phyID}       │
        │      TTL: 2x heartbeat_timeout    │
        │   3. 本地缓存: localConn[connID]  │
        └──────────┬────────────────────────┘
                   ↓
        ┌───────────────────────────────────┐
        │   后续心跳 (每30秒)               │
        │   sess.OnHeartbeat(phyID, now)    │
        │   更新 Redis lastSeen             │
        └──────────┬────────────────────────┘
                   ↓
        ┌───────────────────────────────────┐
        │   设备断开 TCP                    │
        │   ConnContext.Done() 信号         │
        └──────────┬────────────────────────┘
                   ↓
        ┌───────────────────────────────────┐
        │   sess.UnbindByPhy(phyID)         │
        │   1. 从本地缓存删除               │
        │   2. 从 Redis 删除会话数据        │
        │   3. 记录 TCP 断开事件            │
        └───────────────────────────────────┘
```

### 5. 多阶段启动序列

```
                      启动
                        ↓
            ╔═══════════════════════════╗
            ║  阶段 1: 基础设置         ║
            ║ • 指标注册表              ║
            ║ • 就绪跟踪器              ║
            ║ • ServerID 生成           ║
            ╚═════════════╤═════════════╝
                         ↓
            ╔═══════════════════════════╗
            ║  阶段 2: Redis 客户端     ║  ← 必需
            ║ • 连接到 Redis            ║
            ║ • 无法连接时快速失败      ║
            ╚═════════════╤═════════════╝
                         ↓
            ╔═══════════════════════════╗
            ║  阶段 3: 会话管理器       ║
            ║ • 创建 RedisManager       ║
            ╚═════════════╤═════════════╝
                         ↓
            ╔═══════════════════════════╗
            ║  阶段 4: 数据库           ║  ← 必需
            ║ • 连接到 PostgreSQL       ║
            ║ • 运行迁移                ║
            ║ • 设置数据库就绪标志      ║
            ╚═════════════╤═════════════╝
                         ↓
            ╔═══════════════════════════╗
            ║  阶段 5: 处理器           ║
            ║ • 创建 Repository         ║
            ║ • 创建 EventQueue         ║
            ║ • 初始化 AP3000/BKV       ║
            ╚═════════════╤═════════════╝
                         ↓
            ╔═══════════════════════════╗
            ║  阶段 6: HTTP 服务器      ║ (后台)
            ║ • 设置路由                ║
            ║ • 启动监听器              ║
            ╚═════════════╤═════════════╝
                         ↓
            ╔═══════════════════════════╗
            ║  阶段 7: 工作线程         ║ (后台)
            ║ • RedisWorker             ║
            ║ • EventQueueWorkers       ║
            ║ • OrderMonitor            ║
            ╚═════════════╤═════════════╝
                         ↓
            ╔═══════════════════════════╗
            ║  阶段 8: TCP 服务器       ║  ← 最后!
            ║ • 创建监听器              ║
            ║ • 开始接受连接            ║
            ╚═════════════╤═════════════╝
                         ↓
            ╔═══════════════════════════╗
            ║  所有服务就绪!            ║
            ╚═════════════╤═════════════╝
                         ↓
            ┌─────────────────────────┐
            │ 等待 SIGTERM/SIGINT     │
            └────────────┬────────────┘
                         ↓
            ╔═══════════════════════════╗
            ║  阶段 9: 优雅关闭         ║
            ║ • 停止 HTTP/TCP          ║
            ║ • 清理 Redis 会话         ║
            ║ • 关闭数据库连接          ║
            ╚═══════════════════════════╝
```

### 6. 协议检测和分发

```
    原始 TCP 流
           ↓
    前 8 个字节
           ↓
    ┌──────────────────────────────────────┐
    │  Mux.BindToConn.onRead() (首次调用)  │
    │  检查前 8 字节 (魔术字节)            │
    │  for each adapter:                   │
    │    if adapter.Sniff(prefix):         │
    │      找到 → 分发到此适配器           │
    └──────────┬───────────────────────────┘
               ↓
    ┌──────────────────────────────┐
    │  Sniff() 检查                │
    ├──────────────────────────────┤
    │  AP3000: 0x44,0x22,0x4E      │
    │  BKV: 0xFC,0xFE/0xFF         │
    └──────────┬───────────────────┘
               ↓
    ┌──────────────────────────────┐
    │  设置永久处理器              │
    │  handler = adapter.Process   │
    │  (后续字节只发送到此处理器)  │
    └──────────────────────────────┘
```

### 7. Redis存储架构

```
┌────────────────────────────────────────────────────────────┐
│                    REDIS 存储架构                          │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  会话管理:                                                 │
│  ┌──────────────────────────────────────────────────────┐ │
│  │ session:device:{phyID}  (String → JSON)              │ │
│  │ {                                                     │ │
│  │   "phy_id": "GW001",                                 │ │
│  │   "conn_id": "uuid-...",                             │ │
│  │   "server_id": "server-uuid",                        │ │
│  │   "last_seen": "2025-11-10T01:39:00Z",              │ │
│  │   "last_tcp_down": null,                             │ │
│  │   "last_ack_timeout": null                           │ │
│  │ }                                                     │ │
│  │ TTL: 2 × heartbeat_timeout                           │ │
│  └──────────────────────────────────────────────────────┘ │
│                                                            │
│  session:conn:{connID}  (String → phyID)                  │
│  TTL: 2 × heartbeat_timeout                              │
│                                                            │
│  session:server:{serverID}:conns  (Set of connIDs)        │
│  (无 TTL - 手动维护)                                      │
│                                                            │
│  ────────────────────────────────────────────────────────│
│                                                            │
│  出站队列:                                                 │
│  ┌──────────────────────────────────────────────────────┐ │
│  │ outbound:queue  (有序集合)                           │ │
│  │ score = priority * 1e12 + unixnano                   │ │
│  │ member = "msg_id:JSON_MESSAGE_DATA"                  │ │
│  │                                                       │ │
│  │ 操作:                                                 │ │
│  │ - ZADD: 入队新消息                                   │ │
│  │ - ZPOPMIN: 出队 (原子操作)                           │ │
│  │ - ZCARD: 获取长度                                    │ │
│  └──────────────────────────────────────────────────────┘ │
│                                                            │
│  outbound:processing:{phyID}  (哈希)                      │ │
│  TTL: 2 × 消息超时                                        │ │
│                                                            │
│  outbound:dead  (列表)                                    │ │
│  (无 TTL - 累积直到手动清理)                              │ │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

### 8. 错误处理和重试流程

```
    消息入队
           ↓
    ┌─────────────────────────────────┐
    │  检查队列长度                   │
    │  len ≤ 200: 继续                │
    │  200 < len ≤ 500: 拒绝优先级>5  │
    │  500 < len ≤ 1000: 拒绝优先级>2 │
    │  len > 1000: 拒绝优先级>1       │
    └────────┬────────────────────────┘
             ↓
    入队到 Redis
             ↓
    RedisWorker 出队
             ↓
    ┌─────────────────────────────────┐
    │  获取连接                       │
    │  sess.GetConn(phyID)             │
    │  返回 nil 如果:                 │
    │  • 设备不在会话中               │
    │  • ServerID 不匹配              │
    │  • 心跳超时                     │
    └────────┬────────────────────────┘
             ↓
    ┌──────────────────┐
    │  连接可用?       │
    └────┬─────────┬──┘
         │         │
        是         否
         │         │
         ↓         ↓
    ┌────────┐  ┌──────────────────┐
    │ 写入   │  │ 标记失败         │
    │ 帧     │  │ retries++        │
    └────┬───┘  └────┬─────────────┘
         │           │
    ┌────┴───────────┴──────────────┐
    │ 重试次数 < MaxRetry?         │
    └────┬──────────────┬───────────┘
         │              │
        是              否
         │              │
         ↓              ↓
    ┌─────────┐  ┌──────────────┐
    │ 重新入队 │  │ 移至死信队列 │
    └─────────┘  └──────────────┘
```

---

## 文档指南

### 综合文档

- **[CLAUDE.md](CLAUDE.md)** - 完整的架构指南（696行，权威参考）
- **[IoT中间件技术规范.md](docs/IoT中间件技术规范.md)** - 业务规范和状态机定义

### 文档分类

- **🚀 部署类**：面向运维人员
  - [README.md](README.md) - 快速开始
  - [CI/CD指南](docs/CI-CD-GUIDE.md)
  
- **🏗️ 架构类**：面向开发人员
  - 本文档 - 架构图和快速参考
  - [CLAUDE.md](CLAUDE.md) - 详细架构说明
  
- **📡 协议类**：面向协议开发人员
  - [BKV对接总结](docs/协议/BKV设备对接总结.md)
  - [GN组网设备对接指引](docs/协议/设备对接指引-组网设备2024(1).txt)
  
- **🔌 API类**：面向集成开发人员
  - [第三方API文档](docs/api/第三方API文档.md)
  - [事件推送规范](docs/api/事件推送规范.md)

---

## 关键概念

### 1. 多协议网关

系统接受来自使用不同协议（AP3000、BKV）的物联网设备的连接：

- **适配器**：嗅探魔数，检测协议类型
- **解码器**：将原始字节转换为帧
- **路由器**：命令代码→处理器查找
- **处理器**：每种消息类型的业务逻辑

### 2. 异步命令传递

命令通过按优先级排序的Redis队列流转：

- HTTP API请求立即入队（返回202）
- 后台工作线程每100ms轮询队列
- 工作线程在发送前验证设备在线
- 命令在进程重启后仍保留（持久化在Redis中）
- 失败的消息重试最多N次，然后移至死信队列

### 3. 会话管理

设备连接在Redis中跟踪：

- 物理ID（phyID）→连接映射
- 心跳时间戳用于在线检测
- 加权策略考虑TCP断开和ACK超时
- 分布式：跨多个服务器实例工作

### 4. 两层存储

- **PostgreSQL**：持久化数据（设备、订单、命令日志、审计跟踪）
- **Redis**：会话数据、命令队列、去重（高吞吐量）

### 5. 9阶段启动

精心编排确保：
1. 指标 + 状态跟踪器就绪
2. Redis客户端可用（必需）
3. 会话管理器初始化
4. 数据库连接并迁移（必需）
5. 业务处理器创建
6. HTTP服务器启动
7. 后台工作线程启动
8. **TCP服务器最后启动**（在所有依赖之后）
9. SIGTERM时优雅关闭

---

## 文件组织

```
internal/
├── app/
│   ├── bootstrap/app.go          ← 9阶段启动编排
│   ├── tcp.go, http.go, db.go    ← 组件工厂
│   ├── session.go, redis.go      ← 依赖创建
│   └── outbound_adapter.go       ← Redis队列桥接
│
├── tcpserver/
│   ├── server.go                 ← TCP监听器
│   ├── mux.go                    ← 协议检测
│   ├── conn.go                   ← 连接包装器
│   └── limiter.go, rate_limiter.go, circuit_breaker.go
│
├── gateway/
│   └── conn_handler.go           ← 处理器注册
│
├── protocol/
│   ├── adapter/adapter.go        ← 接口
│   ├── ap3000/
│   │   ├── adapter.go, parser.go, decoder.go
│   │   └── handlers.go
│   └── bkv/
│       ├── adapter.go, parser.go, decoder.go
│       └── handlers.go（约1500行）
│
├── session/
│   ├── interface.go              ← SessionManager契约
│   └── redis_manager.go          ← Redis实现
│
├── storage/
│   ├── redis/
│   │   ├── outbound_queue.go     ← 队列操作
│   │   └── client.go
│   └── pg/
│       ├── repo.go               ← 所有数据库查询
│       └── pool.go
│
├── api/
│   ├── routes.go, thirdparty_routes.go
│   ├── thirdparty_handler.go     ← 命令端点
│   └── readonly_handler.go       ← 查询端点
│
├── outbound/
│   ├── redis_worker.go           ← 轮询和传递
│   └── priority.go               ← 优先级计算
│
└── health/
    ├── aggregator.go             ← 复合健康检查
    ├── checker.go, *_checker.go
    └── http_routes.go
```

---

## 常见问题

### Q1: 设备命令如何发送？

```
HTTP POST → ThirdPartyHandler → RedisQueue.Enqueue() 
→ 返回202 → RedisWorker轮询 → 检查设备在线 → 写入socket
```

### Q2: 如果设备在命令期间离线会怎样？

```
RedisWorker检测离线 → 标记失败 → 重试最多3次 → 移至死信队列
```

### Q3: 系统如何检测设备是否在线？

- **简单方式**：5分钟内有心跳
- **加权方式**：最近心跳+1.0，最近TCP断开-0.2，最近ACK超时-0.3，阈值0.5

### Q4: 系统能否水平扩展？

可以！会话存储在Redis中（非本地内存）。每个服务器获得一个UUID。TCP连接本地绑定，但可以通过Redis查询其他服务器的会话。

### Q5: 服务器重启时会发生什么？

Redis队列中的命令持久化。会话数据清理。TCP客户端重新连接（正常流程）。死信队列保留供分析。

### Q6: 命令如何排定优先级？

```
分数 = 优先级 × 1e12 + 纳秒
高优先级命令先出队
队列降级在队列过长时拒绝低优先级
```

---

## 扩展点

1. **新协议**：实现Adapter接口 + 在conn_handler.go中注册
2. **新API端点**：添加到thirdparty_handler.go + thirdparty_routes.go
3. **自定义优先级**：修改outbound/priority.go
4. **自定义健康检查**：添加到internal/health/

---

## 故障排除

| 问题 | 检查方法 |
|------|---------|
| 设备离线？ | 检查Redis：`session:device:{phyID}.lastSeen` |
| 出站队列堆积？ | 检查`ZCARD outbound:queue`，查看工作线程日志 |
| 命令未执行？ | 检查：设备在线？已入队？工作线程运行？ |
| 协议不匹配？ | 验证流的前8字节中的魔数 |
| 连接未绑定？ | 检查mux检测是否与实际协议匹配 |

---

## 相关代码参考

- **入口点**：`cmd/server/main.go`
- **配置**：`internal/config/*.go`
- **迁移**：`db/migrations/*.sql`
- **测试**：`test/e2e/`、`internal/**/*_test.go`

---

## 监控与指标

- **健康检查**：`/health` 端点
- **Prometheus指标**：`/metrics` 端点
- **关键指标**：
  - `device_online_total` - 在线设备数
  - `order_created_total` - 订单创建数
  - `outbound_queue_length` - 队列长度

---

**最后更新**: 2025-11-10  
**详细信息**: 参见 [CLAUDE.md](CLAUDE.md) (696行完整架构指南)

