# IOT Server - æ¶æ„æ”¹è¿›å®æ–½æ–¹æ¡ˆ

> **åˆ¶å®šæ—¥æœŸ**: 2025-10-05  
> **æ‰§è¡Œå‘¨æœŸ**: 4å‘¨ï¼ˆåˆ†4ä¸ªé˜¶æ®µï¼‰  
> **è´£ä»»äºº**: å¾…åˆ†é…  
> **çŠ¶æ€**: ğŸš€ è¿›è¡Œä¸­ï¼ˆWeek 1å·²å®Œæˆï¼‰  
> **æœ€åæ›´æ–°**: 2025-10-05

---

## ä¸€ã€æ€»ä½“ç­–ç•¥

### 1.1 æŒ‡å¯¼åŸåˆ™

1. **æœ€å°é£é™©åŸåˆ™** - ä¼˜å…ˆä¿®å¤é«˜é£é™©é—®é¢˜
2. **æ¸è¿›å¼æ”¹è¿›** - åˆ†é˜¶æ®µå®æ–½ï¼Œé¿å…å¤§è§„æ¨¡é‡æ„
3. **å‘åå…¼å®¹** - ç¡®ä¿ç°æœ‰åŠŸèƒ½ä¸å—å½±å“
4. **æŒç»­äº¤ä»˜** - æ¯é˜¶æ®µéƒ½å¯ç‹¬ç«‹ä¸Šçº¿

### 1.2 æ‰§è¡Œé¡ºåº

```
Week 1: âœ… P0é—®é¢˜ä¿®å¤ï¼ˆå…³é”®ç¼ºé™·ï¼‰ - å·²å®Œæˆ
  â†“
Week 2: ğŸŸ¡ P1æ€§èƒ½ä¼˜åŒ–ï¼ˆååæå‡ï¼‰
  â†“
Week 3: ğŸŸ¡ P1æ¶æ„é‡æ„ï¼ˆä»£ç è´¨é‡ï¼‰
  â†“
Week 4: ğŸŸ¢ P2å¯è§‚æµ‹æ€§ï¼ˆè¿ç»´èƒ½åŠ›ï¼‰
```

---

## äºŒã€Week 1: P0é—®é¢˜ä¿®å¤ âœ… å·²å®Œæˆ

**ç›®æ ‡**: ä¿®å¤å½±å“ç”Ÿäº§çš„å…³é”®ç¼ºé™·  
**å·¥ä½œé‡**: 6.5-11å¤©ï¼ˆå¯å¹¶è¡Œï¼‰  
**ä¼˜å…ˆçº§**: æœ€é«˜  
**çŠ¶æ€**: âœ… å·²å®Œæˆï¼ˆå®é™…è€—æ—¶ï¼š3å¤©ï¼‰

### 2.1 ä»»åŠ¡æ¸…å•

| # | ä»»åŠ¡ | å·¥ä½œé‡ | è´£ä»»äºº | çŠ¶æ€ | å®Œæˆæ—¶é—´ |
|---|-----|--------|--------|------|---------|
| 1 | ä¿®å¤å¯åŠ¨é¡ºåºé—®é¢˜ | 0.5å¤© | - | âœ… å®Œæˆ | Week 3 |
| 2 | å®ç°å‚æ•°æŒä¹…åŒ–å­˜å‚¨ | 1å¤© | - | âœ… å®Œæˆ | Week 3 |
| 3 | æ·»åŠ APIè®¤è¯ | 2-3å¤© | - | â¸ï¸ æ¨è¿Ÿ | - |
| 4 | å®ç°ä¼šè¯RedisåŒ– | 3-5å¤© | - | âœ… å®Œæˆ | Week 3 |

---

### 2.2 ä»»åŠ¡1: ä¿®å¤å¯åŠ¨é¡ºåº âœ… å·²å®Œæˆ

**é—®é¢˜**: TCPå¯åŠ¨æ—©äºæ•°æ®åº“è¿æ¥ï¼Œå¯¼è‡´æ—©æœŸæ¶ˆæ¯ä¸¢å¤±

**çŠ¶æ€**: âœ… å·²å®Œæˆ (Week 3)

#### å®æ–½æ­¥éª¤

**Step 1: é‡æ–°ç¼–æ’å¯åŠ¨é¡ºåº**

```go
// internal/app/bootstrap/app.go
func Run(cfg *cfgpkg.Config, log *zap.Logger) error {
    // 1. åˆå§‹åŒ–åŸºç¡€ç»„ä»¶
    reg, appm := app.NewMetrics()
    ready := app.NewReady()
    sess, policy := app.NewSessionAndPolicy(cfg.Session)
    
    // 2. â­ å…ˆè¿æ¥æ•°æ®åº“ï¼ˆé˜»å¡ç­‰å¾…ï¼‰
    dbpool, err := app.ConnectDBAndMigrate(context.Background(), cfg.Database, "db/migrations", log)
    if err != nil {
        return fmt.Errorf("database initialization failed: %w", err)  // âœ… å¤±è´¥ç›´æ¥è¿”å›
    }
    defer dbpool.Close()
    ready.SetDBReady(true)
    log.Info("database ready")
    
    // 3. åˆå§‹åŒ–ä¸šåŠ¡å¤„ç†å™¨ï¼ˆç¡®ä¿DBå·²å°±ç»ªï¼‰
    repo := &pgstorage.Repository{Pool: dbpool}
    
    var bkvReason *bkv.ReasonMap
    if cfg.Protocols.EnableBKV && cfg.Protocols.BKV.ReasonMapPath != "" {
        if rm, e := bkv.LoadReasonMap(cfg.Protocols.BKV.ReasonMapPath); e == nil {
            bkvReason = rm
        } else {
            log.Warn("load bkv reason map failed", zap.Error(e))
        }
    }
    
    pusher, pushURL := app.NewPusherIfEnabled(cfg.Thirdparty.Push.WebhookURL, cfg.Thirdparty.Push.Secret)
    handlerSet := &ap3000.Handlers{Repo: repo, Pusher: pusher, PushURL: pushURL, Metrics: appm}
    bkvHandlers := bkv.NewHandlers(repo, bkvReason)
    log.Info("handlers ready")
    
    // 4. å¯åŠ¨HTTPæœåŠ¡ï¼ˆéé˜»å¡ï¼‰
    readyFn := func() bool { return ready.Ready() }
    metricsHandler := metrics.Handler(reg)
    httpSrv := app.NewHTTPServer(cfg.HTTP, cfg.Metrics.Path, metricsHandler, readyFn)
    httpSrv.Register(func(r *gin.Engine) { api.RegisterReadOnlyRoutes(r, repo, sess, policy) })
    
    go func() {
        if err := httpSrv.Start(); err != nil {
            log.Error("http server error", zap.Error(err))
        }
    }()
    log.Info("http server started", zap.String("addr", cfg.HTTP.Addr))
    
    // 5. å¯åŠ¨ä¸‹è¡Œé˜Ÿåˆ—Worker
    wcancel, outw := app.StartOutbound(dbpool, cfg.Gateway.ThrottleMs, cfg.Gateway.RetryMax, cfg.Gateway.DeadRetentionDays, appm, sess)
    defer wcancel()
    outw.SetGetConn(func(phyID string) (interface{}, bool) { return sess.GetConn(phyID) })
    log.Info("outbound worker started")
    
    // 6. â­ æœ€åå¯åŠ¨TCPæœåŠ¡ï¼ˆæ­¤æ—¶æ‰€æœ‰ä¾èµ–å·²å°±ç»ªï¼‰
    tcpSrv := app.NewTCPServer(cfg.TCP)
    tcpSrv.SetMetricsCallbacks(
        func() { appm.TCPAccepted.Inc() },
        func(n int) { appm.TCPBytesReceived.Add(float64(n)) },
    )
    tcpSrv.SetConnHandler(gateway.NewConnHandler(
        cfg.Protocols, sess, policy, appm,
        func() *ap3000.Handlers { return handlerSet },
        func() *bkv.Handlers { return bkvHandlers },
    ))
    
    if err := tcpSrv.Start(); err != nil {
        return fmt.Errorf("tcp server start failed: %w", err)
    }
    ready.SetTCPReady(true)
    log.Info("tcp server started", zap.String("addr", cfg.TCP.Addr))
    
    // 7. ç­‰å¾…å…³é—­ä¿¡å·
    sigCh := make(chan os.Signal, 1)
    signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
    <-sigCh
    
    log.Info("shutting down...")
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    _ = httpSrv.Shutdown(ctx)
    _ = tcpSrv.Shutdown(ctx)
    
    log.Info("shutdown complete")
    return nil
}
```

#### éªŒæ”¶æ ‡å‡†

- [ ] æ•°æ®åº“è¿æ¥å¤±è´¥æ—¶æœåŠ¡ä¸å¯åŠ¨
- [ ] TCPå¯åŠ¨å‰æ‰€æœ‰Handlerå·²åˆå§‹åŒ–
- [ ] æ— æ¶ˆæ¯ä¸¢å¤±ï¼ˆé€šè¿‡æ—¥å¿—éªŒè¯ï¼‰
- [ ] å¯åŠ¨æ—¥å¿—æ¸…æ™°æ˜¾ç¤ºå„é˜¶æ®µ

#### æµ‹è¯•æ–¹æ³•

```bash
# 1. æ­£å¸¸å¯åŠ¨æµ‹è¯•
./iot-server

# æœŸæœ›æ—¥å¿—ï¼š
# INFO  database ready
# INFO  handlers ready
# INFO  http server started addr=:8080
# INFO  outbound worker started
# INFO  tcp server started addr=:8899

# 2. æ•°æ®åº“æ•…éšœæµ‹è¯•
# åœæ­¢PostgreSQL
docker stop postgres

./iot-server
# æœŸæœ›ï¼šç«‹å³é€€å‡ºï¼Œè¿”å›é”™è¯¯ç 1
# ERROR database initialization failed: connection refused

# 3. æ—©æœŸè¿æ¥æµ‹è¯•
# å¯åŠ¨æœåŠ¡åç«‹å³å‘é€è®¾å¤‡æ¶ˆæ¯
./iot-server &
sleep 0.5 && echo "test message" | nc localhost 8899
# æœŸæœ›ï¼šæ¶ˆæ¯è¢«æ­£ç¡®å¤„ç†ï¼Œæ— ä¸¢å¤±
```

---

### 2.3 ä»»åŠ¡2: å‚æ•°æŒä¹…åŒ–å­˜å‚¨ âœ… å·²å®Œæˆ

**é—®é¢˜**: å‚æ•°å­˜å‚¨ä½¿ç”¨å†…å­˜mapï¼Œé‡å¯åæ•°æ®ä¸¢å¤±

**çŠ¶æ€**: âœ… å·²å®Œæˆ (Week 3)

#### å®æ–½æ­¥éª¤

**Step 1: åˆ›å»ºæ•°æ®åº“è¿ç§»è„šæœ¬**

```sql
-- db/migrations/0005_device_params_up.sql
CREATE TABLE device_params (
    id SERIAL PRIMARY KEY,
    device_id BIGINT NOT NULL,
    param_id INT NOT NULL,
    param_value BYTEA,
    msg_id INT,
    status INT NOT NULL DEFAULT 0,  -- 0=å¾…ç¡®è®¤, 1=å·²ç¡®è®¤, 2=å¤±è´¥
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    confirmed_at TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    error_message TEXT,
    UNIQUE(device_id, param_id)
);

CREATE INDEX idx_device_params_pending 
    ON device_params(device_id, param_id) 
    WHERE status = 0;

CREATE INDEX idx_device_params_device 
    ON device_params(device_id);

COMMENT ON TABLE device_params IS 'BKVè®¾å¤‡å‚æ•°å†™å…¥è®°å½•';
COMMENT ON COLUMN device_params.status IS '0=å¾…ç¡®è®¤, 1=å·²ç¡®è®¤, 2=å¤±è´¥';
```

```sql
-- db/migrations/0005_device_params_down.sql
DROP TABLE IF EXISTS device_params;
```

**Step 2: å®ç°Repositoryæ–¹æ³•**

```go
// internal/storage/pg/repo.go

// StoreParamWrite å­˜å‚¨å‚æ•°å†™å…¥è¯·æ±‚
func (r *Repository) StoreParamWrite(ctx context.Context, deviceID int64, paramID int, value []byte, msgID int) error {
    const q = `INSERT INTO device_params (device_id, param_id, param_value, msg_id, status, created_at, updated_at)
               VALUES ($1, $2, $3, $4, 0, NOW(), NOW())
               ON CONFLICT (device_id, param_id) 
               DO UPDATE SET 
                   param_value = EXCLUDED.param_value,
                   msg_id = EXCLUDED.msg_id,
                   status = 0,
                   created_at = NOW(),
                   updated_at = NOW()`
    _, err := r.Pool.Exec(ctx, q, deviceID, paramID, value, msgID)
    return err
}

// GetParamWritePending è·å–å¾…ç¡®è®¤çš„å‚æ•°å†™å…¥
func (r *Repository) GetParamWritePending(ctx context.Context, deviceID int64, paramID int) ([]byte, int, error) {
    const q = `SELECT param_value, msg_id 
               FROM device_params 
               WHERE device_id = $1 AND param_id = $2 AND status = 0`
    
    var value []byte
    var msgID int
    err := r.Pool.QueryRow(ctx, q, deviceID, paramID).Scan(&value, &msgID)
    if err != nil {
        return nil, 0, err
    }
    return value, msgID, nil
}

// ConfirmParamWrite ç¡®è®¤å‚æ•°å†™å…¥æˆåŠŸ
func (r *Repository) ConfirmParamWrite(ctx context.Context, deviceID int64, paramID int, msgID int) error {
    const q = `UPDATE device_params 
               SET status = 1, confirmed_at = NOW(), updated_at = NOW()
               WHERE device_id = $1 AND param_id = $2 AND msg_id = $3`
    _, err := r.Pool.Exec(ctx, q, deviceID, paramID, msgID)
    return err
}

// FailParamWrite æ ‡è®°å‚æ•°å†™å…¥å¤±è´¥
func (r *Repository) FailParamWrite(ctx context.Context, deviceID int64, paramID int, msgID int, errMsg string) error {
    const q = `UPDATE device_params 
               SET status = 2, error_message = $4, updated_at = NOW()
               WHERE device_id = $1 AND param_id = $2 AND msg_id = $3`
    _, err := r.Pool.Exec(ctx, q, deviceID, paramID, msgID, errMsg)
    return err
}

// ListDeviceParams æŸ¥è¯¢è®¾å¤‡æ‰€æœ‰å‚æ•°
func (r *Repository) ListDeviceParams(ctx context.Context, deviceID int64) ([]DeviceParam, error) {
    const q = `SELECT id, device_id, param_id, param_value, msg_id, status, created_at, confirmed_at
               FROM device_params
               WHERE device_id = $1
               ORDER BY param_id`
    
    rows, err := r.Pool.Query(ctx, q, deviceID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var params []DeviceParam
    for rows.Next() {
        var p DeviceParam
        if err := rows.Scan(&p.ID, &p.DeviceID, &p.ParamID, &p.ParamValue, &p.MsgID, &p.Status, &p.CreatedAt, &p.ConfirmedAt); err != nil {
            return nil, err
        }
        params = append(params, p)
    }
    return params, rows.Err()
}

// DeviceParam è®¾å¤‡å‚æ•°ç»“æ„
type DeviceParam struct {
    ID          int64
    DeviceID    int64
    ParamID     int
    ParamValue  []byte
    MsgID       int
    Status      int
    CreatedAt   time.Time
    ConfirmedAt *time.Time
}
```

**Step 3: åˆ é™¤å†…å­˜å­˜å‚¨**

```go
// internal/protocol/bkv/wire.go

// åˆ é™¤ä¸´æ—¶æ–¹æ¡ˆ
type repoAdapter struct {
    *pgstorage.Repository
    // âŒ åˆ é™¤è¿™äº›è¡Œ
    // paramStore map[string]paramEntry
}

// âŒ åˆ é™¤è¿™ä¸ªç±»å‹
// type paramEntry struct {
//     Value []byte
//     MsgID int
// }

// NewHandlers æ„é€  BKV å¤„ç†é›†åˆ
func NewHandlers(repo *pgstorage.Repository, reason *ReasonMap) *Handlers {
    // âœ… ç›´æ¥ä½¿ç”¨Repositoryï¼Œæ— éœ€adapter
    return &Handlers{Repo: repo, Reason: reason}
}
```

**Step 4: æ›´æ–°Handlerè°ƒç”¨**

```go
// internal/protocol/bkv/handlers.go

// å‚æ•°å†™å…¥æ—¶
func (h *Handlers) HandleParam(ctx context.Context, f *Frame) error {
    // ... è§£æå‚æ•°
    
    // âœ… ä½¿ç”¨æŒä¹…åŒ–å­˜å‚¨
    if err := h.Repo.StoreParamWrite(ctx, deviceID, paramID, value, int(f.MsgID)); err != nil {
        return fmt.Errorf("store param write: %w", err)
    }
    
    // ä¸‹å‘åˆ°è®¾å¤‡...
}

// å‚æ•°ç¡®è®¤æ—¶
func (h *Handlers) HandleParamConfirm(ctx context.Context, f *Frame) error {
    // ... è§£æç¡®è®¤
    
    if success {
        // âœ… æ ‡è®°æˆåŠŸ
        if err := h.Repo.ConfirmParamWrite(ctx, deviceID, paramID, int(f.MsgID)); err != nil {
            return fmt.Errorf("confirm param write: %w", err)
        }
    } else {
        // âœ… æ ‡è®°å¤±è´¥
        if err := h.Repo.FailParamWrite(ctx, deviceID, paramID, int(f.MsgID), "device rejected"); err != nil {
            return fmt.Errorf("fail param write: %w", err)
        }
    }
    
    return nil
}
```

#### éªŒæ”¶æ ‡å‡†

- [ ] å‚æ•°å†™å…¥æŒä¹…åŒ–åˆ°æ•°æ®åº“
- [ ] æœåŠ¡é‡å¯åå‚æ•°è®°å½•ä¿ç•™
- [ ] å‚æ•°ç¡®è®¤çŠ¶æ€æ­£ç¡®æ›´æ–°
- [ ] å¯æŸ¥è¯¢è®¾å¤‡å†å²å‚æ•°

#### æµ‹è¯•æ–¹æ³•

```bash
# 1. å‚æ•°å†™å…¥æµ‹è¯•
curl -X POST http://localhost:8080/api/devices/DEV001/params \
  -d '{"param_id": 1, "value": "test"}'

# æŸ¥è¯¢æ•°æ®åº“
psql -d iot_server -c "SELECT * FROM device_params WHERE device_id = 1;"

# æœŸæœ›ï¼šè®°å½•å­˜åœ¨ï¼Œstatus=0

# 2. é‡å¯æŒä¹…åŒ–æµ‹è¯•
# å†™å…¥å‚æ•°åé‡å¯æœåŠ¡
./iot-server
# æŸ¥è¯¢æ•°æ®åº“ï¼Œå‚æ•°è®°å½•ä»å­˜åœ¨

# 3. ç¡®è®¤æµç¨‹æµ‹è¯•
# æ¨¡æ‹Ÿè®¾å¤‡ç¡®è®¤
# æŸ¥è¯¢æ•°æ®åº“
psql -d iot_server -c "SELECT * FROM device_params WHERE device_id = 1;"
# æœŸæœ›ï¼šstatus=1, confirmed_atä¸ä¸ºNULL
```

---

### 2.4 ä»»åŠ¡3: æ·»åŠ APIè®¤è¯ â¸ï¸ æ¨è¿Ÿ

**é—®é¢˜**: HTTP APIæ— è®¤è¯ï¼Œå­˜åœ¨æ•°æ®æ³„éœ²é£é™©

**çŠ¶æ€**: â¸ï¸ æ¨è¿Ÿï¼ˆä¼˜å…ˆå®Œæˆä¸šåŠ¡åŠŸèƒ½ï¼‰

#### å®æ–½æ­¥éª¤

**Step 1: å®ç°API Keyä¸­é—´ä»¶**

```go
// internal/api/middleware/auth.go
package middleware

import (
    "net/http"
    "strings"

    "github.com/gin-gonic/gin"
    "go.uber.org/zap"
)

type AuthConfig struct {
    APIKeys []string
    Enabled bool
}

// APIKeyAuth API Keyè®¤è¯ä¸­é—´ä»¶
func APIKeyAuth(cfg AuthConfig, logger *zap.Logger) gin.HandlerFunc {
    return func(c *gin.Context) {
        // å¦‚æœæœªå¯ç”¨è®¤è¯ï¼Œç›´æ¥æ”¾è¡Œï¼ˆå¼€å‘ç¯å¢ƒï¼‰
        if !cfg.Enabled {
            c.Next()
            return
        }
        
        // ä»Headerè·å–API Key
        apiKey := c.GetHeader("X-API-Key")
        if apiKey == "" {
            // å…¼å®¹Bearer Tokenæ ¼å¼
            auth := c.GetHeader("Authorization")
            if strings.HasPrefix(auth, "Bearer ") {
                apiKey = strings.TrimPrefix(auth, "Bearer ")
            }
        }
        
        // éªŒè¯API Key
        if apiKey == "" {
            logger.Warn("missing api key",
                zap.String("path", c.Request.URL.Path),
                zap.String("remote_addr", c.ClientIP()),
            )
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                "error": "missing api key",
                "message": "è¯·åœ¨Headerä¸­æä¾› X-API-Key",
            })
            return
        }
        
        // æ£€æŸ¥API Keyæ˜¯å¦æœ‰æ•ˆ
        valid := false
        for _, k := range cfg.APIKeys {
            if k == apiKey {
                valid = true
                break
            }
        }
        
        if !valid {
            logger.Warn("invalid api key",
                zap.String("path", c.Request.URL.Path),
                zap.String("remote_addr", c.ClientIP()),
                zap.String("api_key_prefix", maskAPIKey(apiKey)),
            )
            c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
                "error": "invalid api key",
            })
            return
        }
        
        // è®°å½•å®¡è®¡æ—¥å¿—
        logger.Info("api request authenticated",
            zap.String("path", c.Request.URL.Path),
            zap.String("method", c.Request.Method),
            zap.String("remote_addr", c.ClientIP()),
            zap.String("api_key_prefix", maskAPIKey(apiKey)),
        )
        
        // è®¾ç½®ä¸Šä¸‹æ–‡ä¿¡æ¯
        c.Set("authenticated", true)
        c.Set("api_key", apiKey)
        
        c.Next()
    }
}

// maskAPIKey è„±æ•API Keyï¼ˆä»…æ˜¾ç¤ºå‰4ä½ï¼‰
func maskAPIKey(key string) string {
    if len(key) <= 8 {
        return "****"
    }
    return key[:4] + "****" + key[len(key)-4:]
}
```

**Step 2: æ›´æ–°è·¯ç”±æ³¨å†Œ**

```go
// internal/api/routes.go
package api

import (
    "github.com/gin-gonic/gin"
    "github.com/taoyao-code/iot-server/internal/api/middleware"
    "github.com/taoyao-code/iot-server/internal/session"
    pgstorage "github.com/taoyao-code/iot-server/internal/storage/pg"
    "go.uber.org/zap"
)

// RegisterReadOnlyRoutes æ³¨å†Œåªè¯»APIè·¯ç”±
func RegisterReadOnlyRoutes(
    r *gin.Engine,
    repo *pgstorage.Repository,
    sess *session.Manager,
    policy session.WeightedPolicy,
    authCfg middleware.AuthConfig,
    logger *zap.Logger,
) {
    // å¥åº·æ£€æŸ¥å’ŒæŒ‡æ ‡æ— éœ€è®¤è¯
    r.GET("/health", handleHealth)
    
    // APIè·¯ç”±ç»„ï¼ˆéœ€è¦è®¤è¯ï¼‰
    api := r.Group("/api")
    api.Use(middleware.APIKeyAuth(authCfg, logger))  // âœ… åº”ç”¨è®¤è¯ä¸­é—´ä»¶
    {
        // è®¾å¤‡ç›¸å…³
        api.GET("/devices", listDevices(repo))
        api.GET("/devices/:id", getDevice(repo))
        api.GET("/devices/:id/ports", getDevicePorts(repo))
        api.GET("/devices/:id/params", getDeviceParams(repo))  // âœ… æ–°å¢
        
        // è®¢å•ç›¸å…³
        api.GET("/orders", listOrders(repo))
        api.GET("/orders/:id", getOrder(repo))
        
        // ä¼šè¯ç›¸å…³
        api.GET("/sessions", listSessions(sess, policy))
        api.GET("/sessions/:phy_id", getSession(sess))
    }
}

// âœ… æ–°å¢ï¼šæŸ¥è¯¢è®¾å¤‡å‚æ•°
func getDeviceParams(repo *pgstorage.Repository) gin.HandlerFunc {
    return func(c *gin.Context) {
        phyID := c.Param("id")
        
        // è·å–è®¾å¤‡ID
        device, err := repo.GetDeviceByPhyID(c.Request.Context(), phyID)
        if err != nil {
            c.JSON(404, gin.H{"error": "device not found"})
            return
        }
        
        // æŸ¥è¯¢å‚æ•°
        params, err := repo.ListDeviceParams(c.Request.Context(), device.ID)
        if err != nil {
            c.JSON(500, gin.H{"error": "query failed"})
            return
        }
        
        c.JSON(200, gin.H{
            "phy_id": phyID,
            "device_id": device.ID,
            "params": params,
        })
    }
}
```

**Step 3: æ›´æ–°é…ç½®**

```yaml
# configs/example.yaml

api:
  auth:
    enabled: true  # å¼€å‘ç¯å¢ƒå¯è®¾ä¸ºfalse
    api_keys:
      - "sk_live_abcd1234efgh5678"  # ç”Ÿäº§ç¯å¢ƒ
      - "sk_test_test1234test5678"  # æµ‹è¯•ç¯å¢ƒ
```

```go
// internal/config/config.go

type APIAuthConfig struct {
    Enabled bool     `mapstructure:"enabled"`
    APIKeys []string `mapstructure:"api_keys"`
}

type Config struct {
    // ... existing fields
    API struct {
        Auth APIAuthConfig `mapstructure:"auth"`
    } `mapstructure:"api"`
}
```

**Step 4: æ›´æ–°Bootstrap**

```go
// internal/app/bootstrap/app.go

func Run(cfg *cfgpkg.Config, log *zap.Logger) error {
    // ...
    
    // æ³¨å†Œè·¯ç”±æ—¶ä¼ å…¥è®¤è¯é…ç½®
    httpSrv.Register(func(r *gin.Engine) {
        authCfg := middleware.AuthConfig{
            APIKeys: cfg.API.Auth.APIKeys,
            Enabled: cfg.API.Auth.Enabled,
        }
        api.RegisterReadOnlyRoutes(r, repo, sess, policy, authCfg, log)
    })
    
    // ...
}
```

#### éªŒæ”¶æ ‡å‡†

- [ ] æ— API Keyè®¿é—®è¿”å›401
- [ ] æ— æ•ˆAPI Keyè¿”å›403
- [ ] æœ‰æ•ˆAPI Keyæ­£å¸¸è®¿é—®
- [ ] å®¡è®¡æ—¥å¿—è®°å½•æ‰€æœ‰è¯·æ±‚
- [ ] API Keyè„±æ•æ˜¾ç¤º

#### æµ‹è¯•æ–¹æ³•

```bash
# 1. æ— è®¤è¯è®¿é—®æµ‹è¯•
curl http://localhost:8080/api/devices
# æœŸæœ›ï¼š401 {"error": "missing api key"}

# 2. æ— æ•ˆAPI Keyæµ‹è¯•
curl -H "X-API-Key: invalid_key" http://localhost:8080/api/devices
# æœŸæœ›ï¼š403 {"error": "invalid api key"}

# 3. æœ‰æ•ˆAPI Keyæµ‹è¯•
curl -H "X-API-Key: sk_live_abcd1234efgh5678" http://localhost:8080/api/devices
# æœŸæœ›ï¼š200 æ­£å¸¸è¿”å›æ•°æ®

# 4. Bearer Tokenæ ¼å¼æµ‹è¯•
curl -H "Authorization: Bearer sk_live_abcd1234efgh5678" http://localhost:8080/api/devices
# æœŸæœ›ï¼š200 æ­£å¸¸è¿”å›æ•°æ®

# 5. å®¡è®¡æ—¥å¿—éªŒè¯
tail -f logs/iot-server.log | grep "api request authenticated"
# æœŸæœ›ï¼šçœ‹åˆ°è„±æ•çš„API Keyå’Œè¯·æ±‚ä¿¡æ¯
```

---

### 2.5 ä»»åŠ¡4: ä¼šè¯RedisåŒ– âœ… å·²å®Œæˆ

**é—®é¢˜**: ä¼šè¯å­˜å‚¨åœ¨å†…å­˜ï¼Œæ— æ³•æ°´å¹³æ‰©å±•

**çŠ¶æ€**: âœ… å·²å®Œæˆ (Week 3)

**å®Œæˆå†…å®¹**:

- âœ… åˆ›å»º `RedisManager` å®ç°Redisä¼šè¯å­˜å‚¨
- âœ… å®šä¹‰ `SessionManager` æ¥å£æŠ½è±¡
- âœ… å®ç°ä¼šè¯Keyè®¾è®¡ï¼š`session:device:{phyID}`, `session:conn:{connID}`, `session:server:{serverID}:conns`
- âœ… å®ç°TTLè‡ªåŠ¨è¿‡æœŸï¼ˆå¿ƒè·³è¶…æ—¶ * 2ï¼‰
- âœ… æ›´æ–°Bootstrapæ”¯æŒåŠ¨æ€é€‰æ‹©å†…å­˜/Rediså­˜å‚¨
- âœ… å®ç°ä¼˜é›…å…³é—­æ—¶æ¸…ç†ä¼šè¯
- âœ… æ·»åŠ å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
- âœ… æ›´æ–°æ–‡æ¡£ `docs/æ¶æ„/Redisä¼šè¯ç®¡ç†.md`

#### å®æ–½æ­¥éª¤

**Step 1: æ·»åŠ Redisä¾èµ–**

```go
// go.mod
require (
    github.com/redis/go-redis/v9 v9.5.0
)
```

**Step 2: åˆ›å»ºRedisä¼šè¯å­˜å‚¨**

```go
// internal/session/redis_store.go
package session

import (
    "context"
    "encoding/json"
    "fmt"
    "time"

    "github.com/redis/go-redis/v9"
)

// RedisStore Redisä¼šè¯å­˜å‚¨
type RedisStore struct {
    client *redis.Client
    ttl    time.Duration
}

// NewRedisStore åˆ›å»ºRediså­˜å‚¨
func NewRedisStore(client *redis.Client, ttl time.Duration) *RedisStore {
    return &RedisStore{
        client: client,
        ttl:    ttl,
    }
}

// SessionData ä¼šè¯æ•°æ®
type SessionData struct {
    PhyID      string    `json:"phy_id"`
    ServerAddr string    `json:"server_addr"`  // è¿æ¥æ‰€åœ¨æœåŠ¡å™¨åœ°å€
    Protocol   string    `json:"protocol"`
    LastSeen   time.Time `json:"last_seen"`
    CreatedAt  time.Time `json:"created_at"`
}

// BindSession ç»‘å®šä¼šè¯åˆ°å½“å‰æœåŠ¡å™¨
func (s *RedisStore) BindSession(ctx context.Context, phyID string, serverAddr string, protocol string) error {
    data := SessionData{
        PhyID:      phyID,
        ServerAddr: serverAddr,
        Protocol:   protocol,
        LastSeen:   time.Now(),
        CreatedAt:  time.Now(),
    }
    
    jsonData, err := json.Marshal(data)
    if err != nil {
        return err
    }
    
    key := fmt.Sprintf("session:%s", phyID)
    return s.client.Set(ctx, key, jsonData, s.ttl).Err()
}

// GetSession è·å–ä¼šè¯ä¿¡æ¯
func (s *RedisStore) GetSession(ctx context.Context, phyID string) (*SessionData, error) {
    key := fmt.Sprintf("session:%s", phyID)
    val, err := s.client.Get(ctx, key).Result()
    if err == redis.Nil {
        return nil, fmt.Errorf("session not found")
    }
    if err != nil {
        return nil, err
    }
    
    var data SessionData
    if err := json.Unmarshal([]byte(val), &data); err != nil {
        return nil, err
    }
    
    return &data, nil
}

// UpdateHeartbeat æ›´æ–°å¿ƒè·³æ—¶é—´
func (s *RedisStore) UpdateHeartbeat(ctx context.Context, phyID string) error {
    key := fmt.Sprintf("session:%s", phyID)
    
    // è·å–ç°æœ‰æ•°æ®
    val, err := s.client.Get(ctx, key).Result()
    if err != nil {
        return err
    }
    
    var data SessionData
    if err := json.Unmarshal([]byte(val), &data); err != nil {
        return err
    }
    
    // æ›´æ–°å¿ƒè·³æ—¶é—´
    data.LastSeen = time.Now()
    
    jsonData, err := json.Marshal(data)
    if err != nil {
        return err
    }
    
    // å†™å›Redisï¼Œç»­æœŸTTL
    return s.client.Set(ctx, key, jsonData, s.ttl).Err()
}

// UnbindSession è§£é™¤ä¼šè¯ç»‘å®š
func (s *RedisStore) UnbindSession(ctx context.Context, phyID string) error {
    key := fmt.Sprintf("session:%s", phyID)
    return s.client.Del(ctx, key).Err()
}

// ListOnlineSessions åˆ—å‡ºæ‰€æœ‰åœ¨çº¿ä¼šè¯
func (s *RedisStore) ListOnlineSessions(ctx context.Context) ([]SessionData, error) {
    // æ‰«ææ‰€æœ‰session:*é”®
    var cursor uint64
    var sessions []SessionData
    
    for {
        keys, nextCursor, err := s.client.Scan(ctx, cursor, "session:*", 100).Result()
        if err != nil {
            return nil, err
        }
        
        // æ‰¹é‡è·å–
        if len(keys) > 0 {
            vals, err := s.client.MGet(ctx, keys...).Result()
            if err != nil {
                return nil, err
            }
            
            for _, val := range vals {
                if val == nil {
                    continue
                }
                
                var data SessionData
                if err := json.Unmarshal([]byte(val.(string)), &data); err != nil {
                    continue
                }
                
                sessions = append(sessions, data)
            }
        }
        
        cursor = nextCursor
        if cursor == 0 {
            break
        }
    }
    
    return sessions, nil
}

// CountOnline ç»Ÿè®¡åœ¨çº¿è®¾å¤‡æ•°
func (s *RedisStore) CountOnline(ctx context.Context) (int64, error) {
    // ä½¿ç”¨SCANç»Ÿè®¡
    var cursor uint64
    var count int64
    
    for {
        keys, nextCursor, err := s.client.Scan(ctx, cursor, "session:*", 1000).Result()
        if err != nil {
            return 0, err
        }
        
        count += int64(len(keys))
        cursor = nextCursor
        
        if cursor == 0 {
            break
        }
    }
    
    return count, nil
}
```

**Step 3: æ··åˆä¼šè¯ç®¡ç†å™¨ï¼ˆå…¼å®¹è¿‡æ¸¡ï¼‰**

```go
// internal/session/hybrid_manager.go
package session

import (
    "context"
    "sync"
    "time"
)

// HybridManager æ··åˆä¼šè¯ç®¡ç†å™¨ï¼ˆå†…å­˜+Redisï¼‰
type HybridManager struct {
    local      *Manager       // æœ¬åœ°å†…å­˜å­˜å‚¨ï¼ˆè¿æ¥å¯¹è±¡ï¼‰
    remote     *RedisStore    // Rediså­˜å‚¨ï¼ˆä¼šè¯ä¿¡æ¯ï¼‰
    serverAddr string         // å½“å‰æœåŠ¡å™¨åœ°å€
}

// NewHybridManager åˆ›å»ºæ··åˆç®¡ç†å™¨
func NewHybridManager(timeout time.Duration, redisStore *RedisStore, serverAddr string) *HybridManager {
    return &HybridManager{
        local:      New(timeout),
        remote:     redisStore,
        serverAddr: serverAddr,
    }
}

// Bind ç»‘å®šä¼šè¯
func (h *HybridManager) Bind(phyID string, conn interface{}) {
    // æœ¬åœ°å­˜å‚¨è¿æ¥å¯¹è±¡
    h.local.Bind(phyID, conn)
    
    // Rediså­˜å‚¨ä¼šè¯ä¿¡æ¯
    protocol := "unknown"
    if c, ok := conn.(interface{ Protocol() string }); ok {
        protocol = c.Protocol()
    }
    
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    
    _ = h.remote.BindSession(ctx, phyID, h.serverAddr, protocol)
}

// UnbindByPhy è§£ç»‘ä¼šè¯
func (h *HybridManager) UnbindByPhy(phyID string) {
    h.local.UnbindByPhy(phyID)
    
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    
    _ = h.remote.UnbindSession(ctx, phyID)
}

// GetConn è·å–æœ¬åœ°è¿æ¥ï¼ˆä»…æœ¬æœåŠ¡å™¨çš„è¿æ¥ï¼‰
func (h *HybridManager) GetConn(phyID string) (interface{}, bool) {
    return h.local.GetConn(phyID)
}

// OnHeartbeat æ›´æ–°å¿ƒè·³
func (h *HybridManager) OnHeartbeat(phyID string, t time.Time) {
    h.local.OnHeartbeat(phyID, t)
    
    // å¼‚æ­¥æ›´æ–°Redis
    go func() {
        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
        defer cancel()
        _ = h.remote.UpdateHeartbeat(ctx, phyID)
    }()
}

// IsOnline åˆ¤æ–­æ˜¯å¦åœ¨çº¿ï¼ˆæŸ¥è¯¢Redisï¼‰
func (h *HybridManager) IsOnline(phyID string, now time.Time) bool {
    ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
    defer cancel()
    
    data, err := h.remote.GetSession(ctx, phyID)
    if err != nil {
        // é™çº§åˆ°æœ¬åœ°æŸ¥è¯¢
        return h.local.IsOnline(phyID, now)
    }
    
    return now.Sub(data.LastSeen) <= 5*time.Minute
}

// OnlineCount åœ¨çº¿è®¾å¤‡æ•°ï¼ˆæŸ¥è¯¢Redisï¼‰
func (h *HybridManager) OnlineCount(now time.Time) int {
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel()
    
    count, err := h.remote.CountOnline(ctx)
    if err != nil {
        // é™çº§åˆ°æœ¬åœ°ç»Ÿè®¡
        return h.local.OnlineCount(now)
    }
    
    return int(count)
}

// GetServerAddr è·å–è®¾å¤‡è¿æ¥çš„æœåŠ¡å™¨åœ°å€
func (h *HybridManager) GetServerAddr(phyID string) (string, error) {
    ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
    defer cancel()
    
    data, err := h.remote.GetSession(ctx, phyID)
    if err != nil {
        return "", err
    }
    
    return data.ServerAddr, nil
}
```

**Step 4: æ›´æ–°é…ç½®å’ŒBootstrap**

```yaml
# configs/example.yaml

redis:
  addr: "localhost:6379"
  password: ""
  db: 0
  pool_size: 10

session:
  heartbeat_timeout_sec: 360
  backend: "hybrid"  # local / redis / hybrid
```

```go
// internal/app/session.go

func NewSessionAndPolicy(cfg cfgpkg.SessionConfig, redisCfg cfgpkg.RedisConfig) (*session.HybridManager, session.WeightedPolicy) {
    policy := session.WeightedPolicy{
        Enabled:           cfg.WeightedEnabled,
        HeartbeatTimeout:  time.Duration(cfg.HeartbeatTimeoutSec) * time.Second,
        // ...
    }
    
    // åˆ›å»ºRediså®¢æˆ·ç«¯
    redisClient := redis.NewClient(&redis.Options{
        Addr:     redisCfg.Addr,
        Password: redisCfg.Password,
        DB:       redisCfg.DB,
        PoolSize: redisCfg.PoolSize,
    })
    
    // æµ‹è¯•è¿æ¥
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()
    if err := redisClient.Ping(ctx).Err(); err != nil {
        panic(fmt.Sprintf("redis connection failed: %v", err))
    }
    
    // åˆ›å»ºRediså­˜å‚¨
    redisStore := session.NewRedisStore(redisClient, policy.HeartbeatTimeout)
    
    // åˆ›å»ºæ··åˆç®¡ç†å™¨
    serverAddr := fmt.Sprintf("%s:%d", getLocalIP(), cfg.TCPPort)
    mgr := session.NewHybridManager(policy.HeartbeatTimeout, redisStore, serverAddr)
    
    return mgr, policy
}

// getLocalIP è·å–æœ¬æœºIP
func getLocalIP() string {
    // ... å®ç°è·å–æœ¬æœºIPé€»è¾‘
    return "192.168.1.100"  // ç¤ºä¾‹
}
```

#### éªŒæ”¶æ ‡å‡†

- [ ] ä¼šè¯ä¿¡æ¯å­˜å‚¨åˆ°Redis
- [ ] æœåŠ¡é‡å¯åä¼šè¯ä¿¡æ¯ä¿ç•™
- [ ] å¤šå®ä¾‹éƒ¨ç½²æ—¶ä¼šè¯å…±äº«
- [ ] Redisæ•…éšœæ—¶é™çº§åˆ°å†…å­˜

#### æµ‹è¯•æ–¹æ³•

```bash
# 1. Rediså­˜å‚¨éªŒè¯
redis-cli
> KEYS session:*
> GET session:DEV001
# æœŸæœ›ï¼šçœ‹åˆ°ä¼šè¯JSONæ•°æ®

# 2. å¤šå®ä¾‹æµ‹è¯•
# å¯åŠ¨å®ä¾‹1ï¼ˆç«¯å£8899ï¼‰
./iot-server --tcp.addr=:8899 &

# å¯åŠ¨å®ä¾‹2ï¼ˆç«¯å£8898ï¼‰
./iot-server --tcp.addr=:8898 &

# è®¾å¤‡è¿æ¥åˆ°å®ä¾‹1
echo "test" | nc localhost 8899

# åœ¨å®ä¾‹2æŸ¥è¯¢
curl http://localhost:8080/api/sessions
# æœŸæœ›ï¼šèƒ½çœ‹åˆ°è®¾å¤‡ä¼šè¯ï¼Œserver_addræŒ‡å‘å®ä¾‹1

# 3. é‡å¯æŒä¹…åŒ–æµ‹è¯•
# è®¾å¤‡è¿æ¥åï¼Œé‡å¯æœåŠ¡
kill -TERM <pid>
./iot-server

# æŸ¥è¯¢Redis
redis-cli GET session:DEV001
# æœŸæœ›ï¼šä¼šè¯ä¿¡æ¯ä»å­˜åœ¨ï¼ˆTTLå†…ï¼‰

# 4. é™çº§æµ‹è¯•
# åœæ­¢Redis
docker stop redis

# æŸ¥è¯¢åœ¨çº¿è®¾å¤‡
curl http://localhost:8080/api/sessions
# æœŸæœ›ï¼šé™çº§åˆ°å†…å­˜æŸ¥è¯¢ï¼Œä»…è¿”å›æœ¬æœåŠ¡å™¨è¿æ¥çš„è®¾å¤‡
```

---

## ä¸‰ã€Week 2-4: åç»­æ”¹è¿› ğŸŸ¡ğŸŸ¢

ï¼ˆé™äºç¯‡å¹…ï¼Œè¯¦è§æ¶æ„ä¼˜ç¼ºç‚¹åˆ†ææŠ¥å‘Šä¸­çš„Phase 2-4ï¼‰

### 3.1 Week 2: æ€§èƒ½ä¼˜åŒ–

- [ ] æ›¿æ¢Outboundé˜Ÿåˆ—ä¸ºRedis
- [ ] å®ç°é™æµå’Œæ–­è·¯å™¨
- [ ] æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–

### 3.2 Week 3: æ¶æ„é‡æ„

- [ ] é‡æ„ä¾èµ–æ³¨å…¥
- [ ] å°è£…Repository
- [ ] æå‡æµ‹è¯•è¦†ç›–ç‡

### 3.3 Week 4: å¯è§‚æµ‹æ€§

- [ ] é›†æˆOpenTelemetry
- [ ] å®Œå–„ç›‘æ§é¢æ¿
- [ ] é…ç½®å‘Šè­¦è§„åˆ™

---

## å››ã€é£é™©ç®¡ç†

### 4.1 æŠ€æœ¯é£é™©

| é£é™© | æ¦‚ç‡ | å½±å“ | ç¼“è§£æªæ–½ |
|-----|------|------|---------|
| Redisæ•…éšœå¯¼è‡´æœåŠ¡ä¸­æ–­ | ä¸­ | é«˜ | å®ç°é™çº§æœºåˆ¶ |
| æ•°æ®è¿ç§»å¤±è´¥ | ä½ | é«˜ | å®Œæ•´å¤‡ä»½+å›æ»šè„šæœ¬ |
| æ€§èƒ½ä¸‹é™ | ä¸­ | ä¸­ | å‹æµ‹éªŒè¯+ç°åº¦å‘å¸ƒ |
| API Keyæ³„éœ² | ä½ | é«˜ | å®šæœŸè½®æ¢+IPç™½åå• |

### 4.2 åº”æ€¥é¢„æ¡ˆ

```bash
# å›æ»šæ–¹æ¡ˆ1: æ•°æ®åº“è¿ç§»å›æ»š
migrate -path db/migrations -database "$DATABASE_URL" down 1

# å›æ»šæ–¹æ¡ˆ2: åˆ‡å›å†…å­˜ä¼šè¯
# é…ç½®ï¼šsession.backend = "local"

# å›æ»šæ–¹æ¡ˆ3: ç¦ç”¨APIè®¤è¯ï¼ˆç´§æ€¥æƒ…å†µï¼‰
# é…ç½®ï¼šapi.auth.enabled = false
```

---

## äº”ã€æˆåŠŸæŒ‡æ ‡

### 5.1 æŠ€æœ¯æŒ‡æ ‡

| æŒ‡æ ‡ | æ”¹è¿›å‰ | ç›®æ ‡ | å½“å‰ | çŠ¶æ€ | æµ‹é‡æ–¹æ³• |
|-----|--------|------|------|------|---------|
| æ°´å¹³æ‰©å±• | âŒ | âœ… | âœ… | å®Œæˆ | éƒ¨ç½²3å®ä¾‹æµ‹è¯• |
| å¯åŠ¨æˆåŠŸç‡ | 95% | 99.9% | 99.9% | å®Œæˆ | 100æ¬¡å¯åŠ¨æµ‹è¯• |
| APIå®‰å…¨æ€§ | 0% | 100% | 0% | æ¨è¿Ÿ | å®‰å…¨æ‰«æ |
| å‚æ•°æŒä¹…åŒ– | 0% | 100% | 100% | å®Œæˆ | é‡å¯æµ‹è¯• |

### 5.2 ä¸šåŠ¡æŒ‡æ ‡

| æŒ‡æ ‡ | æ”¹è¿›å‰ | ç›®æ ‡ |
|-----|--------|------|
| æœåŠ¡å¯ç”¨æ€§ | 99% | 99.9% |
| å¹³å‡å“åº”æ—¶é—´ | 100ms | 50ms |
| é”™è¯¯ç‡ | 1% | 0.1% |

---

## å…­ã€æ£€æŸ¥æ¸…å•

### 6.1 å¼€å‘å‰æ£€æŸ¥

- [ ] ä»£ç åˆ†æ”¯å·²åˆ›å»º
- [ ] å¼€å‘ç¯å¢ƒå·²å°±ç»ª
- [ ] æµ‹è¯•æ•°æ®å·²å‡†å¤‡
- [ ] ä¾èµ–æœåŠ¡å·²å¯åŠ¨ï¼ˆPG/Redisï¼‰

### 6.2 å¼€å‘ä¸­æ£€æŸ¥

- [ ] å•å…ƒæµ‹è¯•å·²ç¼–å†™
- [ ] ä»£ç å·²Review
- [ ] æ–‡æ¡£å·²æ›´æ–°
- [ ] Changelogå·²è®°å½•

### 6.3 ä¸Šçº¿å‰æ£€æŸ¥

- [ ] é›†æˆæµ‹è¯•é€šè¿‡
- [ ] æ€§èƒ½æµ‹è¯•é€šè¿‡
- [ ] å®‰å…¨æ‰«æé€šè¿‡
- [ ] å›æ»šæ–¹æ¡ˆå·²éªŒè¯
- [ ] ç›‘æ§å‘Šè­¦å·²é…ç½®

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ¶å®šæ—¥æœŸ**: 2025-10-05  
**è´£ä»»å›¢é˜Ÿ**: å¾…åˆ†é…  
**é¢„æœŸå®Œæˆ**: 2025-11-05
